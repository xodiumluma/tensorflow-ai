Auto generated patch. Do not edit or delete it, even if empty.
diff -ruN --strip-trailing-cr a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -311,9 +311,6 @@
 - Clang now considers ``noexcept(typeid(expr))`` more carefully, instead of always assuming that ``std::bad_typeid`` can be thrown.
   (`CWG2191: Incorrect result for noexcept(typeid(v)) <https://cplusplus.github.io/CWG/issues/2191.html>`_).
 
-- Clang now correctly implements lookup for the terminal name of a member-qualified nested-name-specifier.
-  (`CWG1835: Dependent member lookup before < <https://cplusplus.github.io/CWG/issues/1835.html>`_).
-
 C Language Changes
 ------------------
 
@@ -714,9 +711,6 @@
 
 - Clang now diagnoses integer constant expressions that are folded to a constant value as an extension in more circumstances. Fixes #GH59863
 
-- Clang now diagnoses missing format attributes for non-template functions and
-  class/struct/union members. Fixes #GH60718
-
 Improvements to Clang's time-trace
 ----------------------------------
 
diff -ruN --strip-trailing-cr a/clang/include/clang/AST/ExprCXX.h b/clang/include/clang/AST/ExprCXX.h
--- a/clang/include/clang/AST/ExprCXX.h
+++ b/clang/include/clang/AST/ExprCXX.h
@@ -3676,9 +3676,9 @@
 /// an implicit access if a qualifier is provided.
 class CXXDependentScopeMemberExpr final
     : public Expr,
-      private llvm::TrailingObjects<
-          CXXDependentScopeMemberExpr, NestedNameSpecifierLoc, DeclAccessPair,
-          ASTTemplateKWAndArgsInfo, TemplateArgumentLoc> {
+      private llvm::TrailingObjects<CXXDependentScopeMemberExpr,
+                                    ASTTemplateKWAndArgsInfo,
+                                    TemplateArgumentLoc, NamedDecl *> {
   friend class ASTStmtReader;
   friend class ASTStmtWriter;
   friend TrailingObjects;
@@ -3691,15 +3691,17 @@
   /// implicit accesses.
   QualType BaseType;
 
+  /// The nested-name-specifier that precedes the member name, if any.
+  /// FIXME: This could be in principle store as a trailing object.
+  /// However the performance impact of doing so should be investigated first.
+  NestedNameSpecifierLoc QualifierLoc;
+
   /// The member to which this member expression refers, which
   /// can be name, overloaded operator, or destructor.
   ///
   /// FIXME: could also be a template-id
   DeclarationNameInfo MemberNameInfo;
 
-  /// The location of the '->' or '.' operator.
-  SourceLocation OperatorLoc;
-
   // CXXDependentScopeMemberExpr is followed by several trailing objects,
   // some of which optional. They are in order:
   //
@@ -3719,16 +3721,8 @@
     return CXXDependentScopeMemberExprBits.HasTemplateKWAndArgsInfo;
   }
 
-  unsigned getNumUnqualifiedLookups() const {
-    return CXXDependentScopeMemberExprBits.NumUnqualifiedLookups;
-  }
-
-  unsigned numTrailingObjects(OverloadToken<NestedNameSpecifierLoc>) const {
-    return hasQualifier();
-  }
-
-  unsigned numTrailingObjects(OverloadToken<DeclAccessPair>) const {
-    return getNumUnqualifiedLookups();
+  bool hasFirstQualifierFoundInScope() const {
+    return CXXDependentScopeMemberExprBits.HasFirstQualifierFoundInScope;
   }
 
   unsigned numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {
@@ -3739,32 +3733,33 @@
     return getNumTemplateArgs();
   }
 
+  unsigned numTrailingObjects(OverloadToken<NamedDecl *>) const {
+    return hasFirstQualifierFoundInScope();
+  }
+
   CXXDependentScopeMemberExpr(const ASTContext &Ctx, Expr *Base,
                               QualType BaseType, bool IsArrow,
                               SourceLocation OperatorLoc,
                               NestedNameSpecifierLoc QualifierLoc,
                               SourceLocation TemplateKWLoc,
-                              ArrayRef<DeclAccessPair> UnqualifiedLookups,
+                              NamedDecl *FirstQualifierFoundInScope,
                               DeclarationNameInfo MemberNameInfo,
                               const TemplateArgumentListInfo *TemplateArgs);
 
-  CXXDependentScopeMemberExpr(EmptyShell Empty, bool HasQualifier,
-                              unsigned NumUnqualifiedLookups,
-                              bool HasTemplateKWAndArgsInfo);
+  CXXDependentScopeMemberExpr(EmptyShell Empty, bool HasTemplateKWAndArgsInfo,
+                              bool HasFirstQualifierFoundInScope);
 
 public:
   static CXXDependentScopeMemberExpr *
   Create(const ASTContext &Ctx, Expr *Base, QualType BaseType, bool IsArrow,
          SourceLocation OperatorLoc, NestedNameSpecifierLoc QualifierLoc,
-         SourceLocation TemplateKWLoc,
-         ArrayRef<DeclAccessPair> UnqualifiedLookups,
+         SourceLocation TemplateKWLoc, NamedDecl *FirstQualifierFoundInScope,
          DeclarationNameInfo MemberNameInfo,
          const TemplateArgumentListInfo *TemplateArgs);
 
   static CXXDependentScopeMemberExpr *
-  CreateEmpty(const ASTContext &Ctx, bool HasQualifier,
-              unsigned NumUnqualifiedLookups, bool HasTemplateKWAndArgsInfo,
-              unsigned NumTemplateArgs);
+  CreateEmpty(const ASTContext &Ctx, bool HasTemplateKWAndArgsInfo,
+              unsigned NumTemplateArgs, bool HasFirstQualifierFoundInScope);
 
   /// True if this is an implicit access, i.e. one in which the
   /// member being accessed was not written in the source.  The source
@@ -3789,35 +3784,34 @@
   bool isArrow() const { return CXXDependentScopeMemberExprBits.IsArrow; }
 
   /// Retrieve the location of the '->' or '.' operator.
-  SourceLocation getOperatorLoc() const { return OperatorLoc; }
-
-  /// Determines whether this member expression had a nested-name-specifier
-  /// prior to the name of the member, e.g., x->Base::foo.
-  bool hasQualifier() const {
-    return CXXDependentScopeMemberExprBits.HasQualifier;
-  }
-
-  /// If the member name was qualified, retrieves the nested-name-specifier
-  /// that precedes the member name, with source-location information.
-  NestedNameSpecifierLoc getQualifierLoc() const {
-    if (!hasQualifier())
-      return NestedNameSpecifierLoc();
-    return *getTrailingObjects<NestedNameSpecifierLoc>();
+  SourceLocation getOperatorLoc() const {
+    return CXXDependentScopeMemberExprBits.OperatorLoc;
   }
 
-  /// If the member name was qualified, retrieves the
-  /// nested-name-specifier that precedes the member name. Otherwise, returns
-  /// NULL.
+  /// Retrieve the nested-name-specifier that qualifies the member name.
   NestedNameSpecifier *getQualifier() const {
-    return getQualifierLoc().getNestedNameSpecifier();
+    return QualifierLoc.getNestedNameSpecifier();
   }
 
-  /// Retrieve the declarations found by unqualified lookup for the first
-  /// component name of the nested-name-specifier, if any.
-  ArrayRef<DeclAccessPair> unqualified_lookups() const {
-    if (!getNumUnqualifiedLookups())
-      return std::nullopt;
-    return {getTrailingObjects<DeclAccessPair>(), getNumUnqualifiedLookups()};
+  /// Retrieve the nested-name-specifier that qualifies the member
+  /// name, with source location information.
+  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }
+
+  /// Retrieve the first part of the nested-name-specifier that was
+  /// found in the scope of the member access expression when the member access
+  /// was initially parsed.
+  ///
+  /// This function only returns a useful result when member access expression
+  /// uses a qualified member name, e.g., "x.Base::f". Here, the declaration
+  /// returned by this function describes what was found by unqualified name
+  /// lookup for the identifier "Base" within the scope of the member access
+  /// expression itself. At template instantiation time, this information is
+  /// combined with the results of name lookup into the type of the object
+  /// expression itself (the class type of x).
+  NamedDecl *getFirstQualifierFoundInScope() const {
+    if (!hasFirstQualifierFoundInScope())
+      return nullptr;
+    return *getTrailingObjects<NamedDecl *>();
   }
 
   /// Retrieve the name of the member that this expression refers to.
diff -ruN --strip-trailing-cr a/clang/include/clang/AST/Stmt.h b/clang/include/clang/AST/Stmt.h
--- a/clang/include/clang/AST/Stmt.h
+++ b/clang/include/clang/AST/Stmt.h
@@ -1020,19 +1020,18 @@
     LLVM_PREFERRED_TYPE(bool)
     unsigned IsArrow : 1;
 
-    /// True if this member expression used a nested-name-specifier to
-    /// refer to the member, e.g., "x->Base::f".
-    LLVM_PREFERRED_TYPE(bool)
-    unsigned HasQualifier : 1;
-
     /// Whether this member expression has info for explicit template
     /// keyword and arguments.
     LLVM_PREFERRED_TYPE(bool)
     unsigned HasTemplateKWAndArgsInfo : 1;
 
-    /// Number of declarations found by unqualified lookup for the
-    /// first component name of the nested-name-specifier.
-    unsigned NumUnqualifiedLookups;
+    /// See getFirstQualifierFoundInScope() and the comment listing
+    /// the trailing objects.
+    LLVM_PREFERRED_TYPE(bool)
+    unsigned HasFirstQualifierFoundInScope : 1;
+
+    /// The location of the '->' or '.' operator.
+    SourceLocation OperatorLoc;
   };
 
   class OverloadExprBitfields {
diff -ruN --strip-trailing-cr a/clang/include/clang/AST/UnresolvedSet.h b/clang/include/clang/AST/UnresolvedSet.h
--- a/clang/include/clang/AST/UnresolvedSet.h
+++ b/clang/include/clang/AST/UnresolvedSet.h
@@ -97,10 +97,6 @@
     decls().push_back(DeclAccessPair::make(D, AS));
   }
 
-  void addAllDecls(ArrayRef<DeclAccessPair> Other) {
-    append(iterator(Other.begin()), iterator(Other.end()));
-  }
-
   /// Replaces the given declaration with the new one, once.
   ///
   /// \return true if the set changed
diff -ruN --strip-trailing-cr a/clang/include/clang/Basic/DiagnosticGroups.td b/clang/include/clang/Basic/DiagnosticGroups.td
--- a/clang/include/clang/Basic/DiagnosticGroups.td
+++ b/clang/include/clang/Basic/DiagnosticGroups.td
@@ -525,6 +525,7 @@
 def MaxUnsignedZero : DiagGroup<"max-unsigned-zero">;
 def MissingBraces : DiagGroup<"missing-braces">;
 def MissingDeclarations: DiagGroup<"missing-declarations">;
+def : DiagGroup<"missing-format-attribute">;
 def MissingIncludeDirs : DiagGroup<"missing-include-dirs">;
 def MissingNoreturn : DiagGroup<"missing-noreturn">;
 def MultiChar : DiagGroup<"multichar">;
diff -ruN --strip-trailing-cr a/clang/include/clang/Basic/DiagnosticParseKinds.td b/clang/include/clang/Basic/DiagnosticParseKinds.td
--- a/clang/include/clang/Basic/DiagnosticParseKinds.td
+++ b/clang/include/clang/Basic/DiagnosticParseKinds.td
@@ -895,7 +895,9 @@
   "keyword">, InGroup<DiagGroup<"missing-template-arg-list-after-template-kw">>,
   DefaultError;
 
-def ext_missing_dependent_template_keyword : ExtWarn<
+def err_missing_dependent_template_keyword : Error<
+  "use 'template' keyword to treat '%0' as a dependent template name">;
+def warn_missing_dependent_template_keyword : ExtWarn<
   "use 'template' keyword to treat '%0' as a dependent template name">;
 
 def ext_extern_template : Extension<
diff -ruN --strip-trailing-cr a/clang/include/clang/Basic/DiagnosticSemaKinds.td b/clang/include/clang/Basic/DiagnosticSemaKinds.td
--- a/clang/include/clang/Basic/DiagnosticSemaKinds.td
+++ b/clang/include/clang/Basic/DiagnosticSemaKinds.td
@@ -1031,9 +1031,6 @@
 def err_opencl_invalid_return : Error<
   "declaring function return value of type %0 is not allowed %select{; did you forget * ?|}1">;
 def warn_enum_value_overflow : Warning<"overflow in enumeration value">;
-def warn_missing_format_attribute : Warning<
-  "diagnostic behavior may be improved by adding the %0 format attribute to the declaration of %1">,
-  InGroup<DiagGroup<"missing-format-attribute">>, DefaultIgnore;
 def warn_pragma_options_align_reset_failed : Warning<
   "#pragma options align=reset failed: %0">,
   InGroup<IgnoredPragmas>;
diff -ruN --strip-trailing-cr a/clang/include/clang/Parse/Parser.h b/clang/include/clang/Parse/Parser.h
--- a/clang/include/clang/Parse/Parser.h
+++ b/clang/include/clang/Parse/Parser.h
@@ -3368,11 +3368,15 @@
   BaseResult ParseBaseSpecifier(Decl *ClassDecl);
   AccessSpecifier getAccessSpecifierIfPresent() const;
 
-  bool ParseUnqualifiedIdTemplateId(
-      CXXScopeSpec &SS, ParsedType ObjectType, bool ObjectHadErrors,
-      SourceLocation TemplateKWLoc, SourceLocation TildeLoc,
-      IdentifierInfo *Name, SourceLocation NameLoc, bool EnteringContext,
-      UnqualifiedId &Id, bool AssumeTemplateId);
+  bool ParseUnqualifiedIdTemplateId(CXXScopeSpec &SS,
+                                    ParsedType ObjectType,
+                                    bool ObjectHadErrors,
+                                    SourceLocation TemplateKWLoc,
+                                    IdentifierInfo *Name,
+                                    SourceLocation NameLoc,
+                                    bool EnteringContext,
+                                    UnqualifiedId &Id,
+                                    bool AssumeTemplateId);
   bool ParseUnqualifiedIdOperator(CXXScopeSpec &SS, bool EnteringContext,
                                   ParsedType ObjectType,
                                   UnqualifiedId &Result);
diff -ruN --strip-trailing-cr a/clang/include/clang/Sema/Attr.h b/clang/include/clang/Sema/Attr.h
--- a/clang/include/clang/Sema/Attr.h
+++ b/clang/include/clang/Sema/Attr.h
@@ -123,13 +123,6 @@
   return false;
 }
 
-inline bool checkIfMethodHasImplicitObjectParameter(const Decl *D) {
-  if (const auto *MethodDecl = dyn_cast<CXXMethodDecl>(D))
-    return MethodDecl->isInstance() &&
-           !MethodDecl->hasCXXExplicitFunctionObjectParameter();
-  return false;
-}
-
 /// Diagnose mutually exclusive attributes when present on a given
 /// declaration. Returns true if diagnosed.
 template <typename AttrTy>
diff -ruN --strip-trailing-cr a/clang/include/clang/Sema/DeclSpec.h b/clang/include/clang/Sema/DeclSpec.h
--- a/clang/include/clang/Sema/DeclSpec.h
+++ b/clang/include/clang/Sema/DeclSpec.h
@@ -75,7 +75,6 @@
   SourceRange Range;
   NestedNameSpecifierLocBuilder Builder;
   ArrayRef<TemplateParameterList *> TemplateParamLists;
-  ArrayRef<DeclAccessPair> UnqualifiedLookups;
 
 public:
   SourceRange getRange() const { return Range; }
@@ -92,13 +91,6 @@
     return TemplateParamLists;
   }
 
-  void setUnqualifiedLookups(ArrayRef<DeclAccessPair> Found) {
-    UnqualifiedLookups = Found;
-  }
-  ArrayRef<DeclAccessPair> getUnqualifiedLookups() const {
-    return UnqualifiedLookups;
-  }
-
   /// Retrieve the representation of the nested-name-specifier.
   NestedNameSpecifier *getScopeRep() const {
     return Builder.getRepresentation();
diff -ruN --strip-trailing-cr a/clang/include/clang/Sema/Lookup.h b/clang/include/clang/Sema/Lookup.h
--- a/clang/include/clang/Sema/Lookup.h
+++ b/clang/include/clang/Sema/Lookup.h
@@ -483,15 +483,11 @@
     ResultKind = Found;
   }
 
-  void addAllDecls(ArrayRef<DeclAccessPair> Other) {
-    Decls.addAllDecls(Other);
-    ResultKind = Found;
-  }
-
   /// Add all the declarations from another set of lookup
   /// results.
   void addAllDecls(const LookupResult &Other) {
-    addAllDecls(Other.Decls.pairs());
+    Decls.append(Other.Decls.begin(), Other.Decls.end());
+    ResultKind = Found;
   }
 
   /// Determine whether no result was found because we could not
diff -ruN --strip-trailing-cr a/clang/include/clang/Sema/Sema.h b/clang/include/clang/Sema/Sema.h
--- a/clang/include/clang/Sema/Sema.h
+++ b/clang/include/clang/Sema/Sema.h
@@ -2802,8 +2802,7 @@
   /// (e.g., Base::), perform name lookup for that identifier as a
   /// nested-name-specifier within the given scope, and return the result of
   /// that name lookup.
-  bool LookupFirstQualifierInScope(Scope *S, NestedNameSpecifier *NNS,
-                                   UnresolvedSetImpl &R);
+  NamedDecl *FindFirstQualifierInScope(Scope *S, NestedNameSpecifier *NNS);
 
   /// Keeps information about an identifier in a nested-name-spec.
   ///
@@ -2843,6 +2842,9 @@
   /// \param EnteringContext If true, enter the context specified by the
   ///        nested-name-specifier.
   /// \param SS Optional nested name specifier preceding the identifier.
+  /// \param ScopeLookupResult Provides the result of name lookup within the
+  ///        scope of the nested-name-specifier that was computed at template
+  ///        definition time.
   /// \param ErrorRecoveryLookup Specifies if the method is called to improve
   ///        error recovery and what kind of recovery is performed.
   /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'
@@ -2851,6 +2853,11 @@
   ///        not '::'.
   /// \param OnlyNamespace If true, only considers namespaces in lookup.
   ///
+  /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in
+  /// that it contains an extra parameter \p ScopeLookupResult, which provides
+  /// the result of name lookup within the scope of the nested-name-specifier
+  /// that was computed at template definition time.
+  ///
   /// If ErrorRecoveryLookup is true, then this call is used to improve error
   /// recovery.  This means that it should not emit diagnostics, it should
   /// just return true on failure.  It also means it should only return a valid
@@ -2859,6 +2866,7 @@
   /// specifier.
   bool BuildCXXNestedNameSpecifier(Scope *S, NestedNameSpecInfo &IdInfo,
                                    bool EnteringContext, CXXScopeSpec &SS,
+                                   NamedDecl *ScopeLookupResult,
                                    bool ErrorRecoveryLookup,
                                    bool *IsCorrectedToColon = nullptr,
                                    bool OnlyNamespace = false);
@@ -4594,10 +4602,6 @@
 
   enum class RetainOwnershipKind { NS, CF, OS };
 
-  void DiagnoseMissingFormatAttributes(Stmt *Body, const FunctionDecl *FDecl);
-  std::vector<FormatAttr *>
-  GetMissingFormatAttributes(Stmt *Body, const FunctionDecl *FDecl);
-
   UuidAttr *mergeUuidAttr(Decl *D, const AttributeCommonInfo &CI,
                           StringRef UuidAsWritten, MSGuidDecl *GuidDecl);
 
@@ -8562,12 +8566,11 @@
                           const TemplateArgumentListInfo *TemplateArgs,
                           bool IsDefiniteInstance, const Scope *S);
 
-  ExprResult
-  ActOnDependentMemberExpr(Expr *Base, QualType BaseType, bool IsArrow,
-                           SourceLocation OpLoc, const CXXScopeSpec &SS,
-                           SourceLocation TemplateKWLoc,
-                           const DeclarationNameInfo &NameInfo,
-                           const TemplateArgumentListInfo *TemplateArgs);
+  ExprResult ActOnDependentMemberExpr(
+      Expr *Base, QualType BaseType, bool IsArrow, SourceLocation OpLoc,
+      const CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
+      NamedDecl *FirstQualifierInScope, const DeclarationNameInfo &NameInfo,
+      const TemplateArgumentListInfo *TemplateArgs);
 
   /// The main callback when the parser finds something like
   ///   expression . [nested-name-specifier] identifier
@@ -8623,14 +8626,15 @@
   ExprResult BuildMemberReferenceExpr(
       Expr *Base, QualType BaseType, SourceLocation OpLoc, bool IsArrow,
       CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
-      const DeclarationNameInfo &NameInfo,
+      NamedDecl *FirstQualifierInScope, const DeclarationNameInfo &NameInfo,
       const TemplateArgumentListInfo *TemplateArgs, const Scope *S,
       ActOnMemberAccessExtraArgs *ExtraArgs = nullptr);
 
   ExprResult
   BuildMemberReferenceExpr(Expr *Base, QualType BaseType, SourceLocation OpLoc,
                            bool IsArrow, const CXXScopeSpec &SS,
-                           SourceLocation TemplateKWLoc, LookupResult &R,
+                           SourceLocation TemplateKWLoc,
+                           NamedDecl *FirstQualifierInScope, LookupResult &R,
                            const TemplateArgumentListInfo *TemplateArgs,
                            const Scope *S, bool SuppressQualifierCheck = false,
                            ActOnMemberAccessExtraArgs *ExtraArgs = nullptr);
@@ -11118,14 +11122,15 @@
                      QualType ObjectType, bool EnteringContext,
                      RequiredTemplateKind RequiredTemplate = SourceLocation(),
                      AssumedTemplateKind *ATK = nullptr,
-                     bool AllowTypoCorrection = true, bool MayBeNNS = false);
+                     bool AllowTypoCorrection = true);
 
-  TemplateNameKind
-  isTemplateName(Scope *S, CXXScopeSpec &SS, bool hasTemplateKeyword,
-                 const UnqualifiedId &Name, ParsedType ObjectType,
-                 bool EnteringContext, TemplateTy &Template,
-                 bool &MemberOfUnknownSpecialization,
-                 bool Disambiguation = false, bool MayBeNNS = false);
+  TemplateNameKind isTemplateName(Scope *S, CXXScopeSpec &SS,
+                                  bool hasTemplateKeyword,
+                                  const UnqualifiedId &Name,
+                                  ParsedType ObjectType, bool EnteringContext,
+                                  TemplateTy &Template,
+                                  bool &MemberOfUnknownSpecialization,
+                                  bool Disambiguation = false);
 
   /// Try to resolve an undeclared template name as a type template.
   ///
@@ -11454,11 +11459,12 @@
   /// For example, given "x.MetaFun::template apply", the scope specifier
   /// \p SS will be "MetaFun::", \p TemplateKWLoc contains the location
   /// of the "template" keyword, and "apply" is the \p Name.
-  TemplateNameKind
-  ActOnTemplateName(Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
-                    const UnqualifiedId &Name, ParsedType ObjectType,
-                    bool EnteringContext, TemplateTy &Template,
-                    bool AllowInjectedClassName = false, bool MayBeNNS = false);
+  TemplateNameKind ActOnTemplateName(Scope *S, CXXScopeSpec &SS,
+                                     SourceLocation TemplateKWLoc,
+                                     const UnqualifiedId &Name,
+                                     ParsedType ObjectType,
+                                     bool EnteringContext, TemplateTy &Template,
+                                     bool AllowInjectedClassName = false);
 
   DeclResult ActOnClassTemplateSpecialization(
       Scope *S, unsigned TagSpec, TagUseKind TUK, SourceLocation KWLoc,
diff -ruN --strip-trailing-cr a/clang/lib/AST/ASTImporter.cpp b/clang/lib/AST/ASTImporter.cpp
--- a/clang/lib/AST/ASTImporter.cpp
+++ b/clang/lib/AST/ASTImporter.cpp
@@ -8439,14 +8439,8 @@
   auto ToOperatorLoc = importChecked(Err, E->getOperatorLoc());
   auto ToQualifierLoc = importChecked(Err, E->getQualifierLoc());
   auto ToTemplateKeywordLoc = importChecked(Err, E->getTemplateKeywordLoc());
-
-  UnresolvedSet<8> ToUnqualifiedLookups;
-  for (auto D : E->unqualified_lookups())
-    if (auto ToDOrErr = import(D.getDecl()))
-      ToUnqualifiedLookups.addDecl(*ToDOrErr);
-    else
-      return ToDOrErr.takeError();
-
+  auto ToFirstQualifierFoundInScope =
+      importChecked(Err, E->getFirstQualifierFoundInScope());
   if (Err)
     return std::move(Err);
 
@@ -8480,7 +8474,7 @@
 
   return CXXDependentScopeMemberExpr::Create(
       Importer.getToContext(), ToBase, ToType, E->isArrow(), ToOperatorLoc,
-      ToQualifierLoc, ToTemplateKeywordLoc, ToUnqualifiedLookups.pairs(),
+      ToQualifierLoc, ToTemplateKeywordLoc, ToFirstQualifierFoundInScope,
       ToMemberNameInfo, ResInfo);
 }
 
diff -ruN --strip-trailing-cr a/clang/lib/AST/ExprCXX.cpp b/clang/lib/AST/ExprCXX.cpp
--- a/clang/lib/AST/ExprCXX.cpp
+++ b/clang/lib/AST/ExprCXX.cpp
@@ -1489,27 +1489,19 @@
 CXXDependentScopeMemberExpr::CXXDependentScopeMemberExpr(
     const ASTContext &Ctx, Expr *Base, QualType BaseType, bool IsArrow,
     SourceLocation OperatorLoc, NestedNameSpecifierLoc QualifierLoc,
-    SourceLocation TemplateKWLoc, ArrayRef<DeclAccessPair> UnqualifiedLookups,
+    SourceLocation TemplateKWLoc, NamedDecl *FirstQualifierFoundInScope,
     DeclarationNameInfo MemberNameInfo,
     const TemplateArgumentListInfo *TemplateArgs)
     : Expr(CXXDependentScopeMemberExprClass, Ctx.DependentTy, VK_LValue,
            OK_Ordinary),
-      Base(Base), BaseType(BaseType), MemberNameInfo(MemberNameInfo),
-      OperatorLoc(OperatorLoc) {
+      Base(Base), BaseType(BaseType), QualifierLoc(QualifierLoc),
+      MemberNameInfo(MemberNameInfo) {
   CXXDependentScopeMemberExprBits.IsArrow = IsArrow;
-  CXXDependentScopeMemberExprBits.HasQualifier = QualifierLoc.hasQualifier();
-  CXXDependentScopeMemberExprBits.NumUnqualifiedLookups =
-      UnqualifiedLookups.size();
   CXXDependentScopeMemberExprBits.HasTemplateKWAndArgsInfo =
       (TemplateArgs != nullptr) || TemplateKWLoc.isValid();
-
-  if (hasQualifier())
-    new (getTrailingObjects<NestedNameSpecifierLoc>())
-        NestedNameSpecifierLoc(QualifierLoc);
-
-  std::uninitialized_copy_n(UnqualifiedLookups.data(),
-                            UnqualifiedLookups.size(),
-                            getTrailingObjects<DeclAccessPair>());
+  CXXDependentScopeMemberExprBits.HasFirstQualifierFoundInScope =
+      FirstQualifierFoundInScope != nullptr;
+  CXXDependentScopeMemberExprBits.OperatorLoc = OperatorLoc;
 
   if (TemplateArgs) {
     auto Deps = TemplateArgumentDependence::None;
@@ -1521,59 +1513,54 @@
         TemplateKWLoc);
   }
 
+  if (hasFirstQualifierFoundInScope())
+    *getTrailingObjects<NamedDecl *>() = FirstQualifierFoundInScope;
   setDependence(computeDependence(this));
 }
 
 CXXDependentScopeMemberExpr::CXXDependentScopeMemberExpr(
-    EmptyShell Empty, bool HasQualifier, unsigned NumUnqualifiedLookups,
-    bool HasTemplateKWAndArgsInfo)
+    EmptyShell Empty, bool HasTemplateKWAndArgsInfo,
+    bool HasFirstQualifierFoundInScope)
     : Expr(CXXDependentScopeMemberExprClass, Empty) {
-  CXXDependentScopeMemberExprBits.HasQualifier = HasQualifier;
-  CXXDependentScopeMemberExprBits.NumUnqualifiedLookups = NumUnqualifiedLookups;
   CXXDependentScopeMemberExprBits.HasTemplateKWAndArgsInfo =
       HasTemplateKWAndArgsInfo;
+  CXXDependentScopeMemberExprBits.HasFirstQualifierFoundInScope =
+      HasFirstQualifierFoundInScope;
 }
 
 CXXDependentScopeMemberExpr *CXXDependentScopeMemberExpr::Create(
     const ASTContext &Ctx, Expr *Base, QualType BaseType, bool IsArrow,
     SourceLocation OperatorLoc, NestedNameSpecifierLoc QualifierLoc,
-    SourceLocation TemplateKWLoc, ArrayRef<DeclAccessPair> UnqualifiedLookups,
+    SourceLocation TemplateKWLoc, NamedDecl *FirstQualifierFoundInScope,
     DeclarationNameInfo MemberNameInfo,
     const TemplateArgumentListInfo *TemplateArgs) {
-  bool HasQualifier = QualifierLoc.hasQualifier();
-  unsigned NumUnqualifiedLookups = UnqualifiedLookups.size();
-  assert(!NumUnqualifiedLookups || HasQualifier);
   bool HasTemplateKWAndArgsInfo =
       (TemplateArgs != nullptr) || TemplateKWLoc.isValid();
   unsigned NumTemplateArgs = TemplateArgs ? TemplateArgs->size() : 0;
-  unsigned Size =
-      totalSizeToAlloc<NestedNameSpecifierLoc, DeclAccessPair,
-                       ASTTemplateKWAndArgsInfo, TemplateArgumentLoc>(
-          HasQualifier, NumUnqualifiedLookups, HasTemplateKWAndArgsInfo,
-          NumTemplateArgs);
+  bool HasFirstQualifierFoundInScope = FirstQualifierFoundInScope != nullptr;
+
+  unsigned Size = totalSizeToAlloc<ASTTemplateKWAndArgsInfo,
+                                   TemplateArgumentLoc, NamedDecl *>(
+      HasTemplateKWAndArgsInfo, NumTemplateArgs, HasFirstQualifierFoundInScope);
 
   void *Mem = Ctx.Allocate(Size, alignof(CXXDependentScopeMemberExpr));
   return new (Mem) CXXDependentScopeMemberExpr(
       Ctx, Base, BaseType, IsArrow, OperatorLoc, QualifierLoc, TemplateKWLoc,
-      UnqualifiedLookups, MemberNameInfo, TemplateArgs);
+      FirstQualifierFoundInScope, MemberNameInfo, TemplateArgs);
 }
 
 CXXDependentScopeMemberExpr *CXXDependentScopeMemberExpr::CreateEmpty(
-    const ASTContext &Ctx, bool HasQualifier, unsigned NumUnqualifiedLookups,
-    bool HasTemplateKWAndArgsInfo, unsigned NumTemplateArgs) {
-  assert(!NumTemplateArgs || HasTemplateKWAndArgsInfo);
-  assert(!NumUnqualifiedLookups || HasQualifier);
-
-  unsigned Size =
-      totalSizeToAlloc<NestedNameSpecifierLoc, DeclAccessPair,
-                       ASTTemplateKWAndArgsInfo, TemplateArgumentLoc>(
-          HasQualifier, NumUnqualifiedLookups, HasTemplateKWAndArgsInfo,
-          NumTemplateArgs);
+    const ASTContext &Ctx, bool HasTemplateKWAndArgsInfo,
+    unsigned NumTemplateArgs, bool HasFirstQualifierFoundInScope) {
+  assert(NumTemplateArgs == 0 || HasTemplateKWAndArgsInfo);
+
+  unsigned Size = totalSizeToAlloc<ASTTemplateKWAndArgsInfo,
+                                   TemplateArgumentLoc, NamedDecl *>(
+      HasTemplateKWAndArgsInfo, NumTemplateArgs, HasFirstQualifierFoundInScope);
 
   void *Mem = Ctx.Allocate(Size, alignof(CXXDependentScopeMemberExpr));
-  return new (Mem) CXXDependentScopeMemberExpr(EmptyShell(), HasQualifier,
-                                               NumUnqualifiedLookups,
-                                               HasTemplateKWAndArgsInfo);
+  return new (Mem) CXXDependentScopeMemberExpr(
+      EmptyShell(), HasTemplateKWAndArgsInfo, HasFirstQualifierFoundInScope);
 }
 
 CXXThisExpr *CXXThisExpr::Create(const ASTContext &Ctx, SourceLocation L,
diff -ruN --strip-trailing-cr a/clang/lib/AST/ItaniumMangle.cpp b/clang/lib/AST/ItaniumMangle.cpp
--- a/clang/lib/AST/ItaniumMangle.cpp
+++ b/clang/lib/AST/ItaniumMangle.cpp
@@ -594,10 +594,11 @@
   void mangleMemberExprBase(const Expr *base, bool isArrow);
   void mangleMemberExpr(const Expr *base, bool isArrow,
                         NestedNameSpecifier *qualifier,
-                        ArrayRef<DeclAccessPair> UnqualifiedLookups,
+                        NamedDecl *firstQualifierLookup,
                         DeclarationName name,
                         const TemplateArgumentLoc *TemplateArgs,
-                        unsigned NumTemplateArgs, unsigned knownArity);
+                        unsigned NumTemplateArgs,
+                        unsigned knownArity);
   void mangleCastExpression(const Expr *E, StringRef CastEncoding);
   void mangleInitListElements(const InitListExpr *InitList);
   void mangleRequirement(SourceLocation RequiresExprLoc,
@@ -4495,11 +4496,14 @@
 }
 
 /// Mangles a member expression.
-void CXXNameMangler::mangleMemberExpr(
-    const Expr *base, bool isArrow, NestedNameSpecifier *qualifier,
-    ArrayRef<DeclAccessPair> UnqualifiedLookups, DeclarationName member,
-    const TemplateArgumentLoc *TemplateArgs, unsigned NumTemplateArgs,
-    unsigned arity) {
+void CXXNameMangler::mangleMemberExpr(const Expr *base,
+                                      bool isArrow,
+                                      NestedNameSpecifier *qualifier,
+                                      NamedDecl *firstQualifierLookup,
+                                      DeclarationName member,
+                                      const TemplateArgumentLoc *TemplateArgs,
+                                      unsigned NumTemplateArgs,
+                                      unsigned arity) {
   // <expression> ::= dt <expression> <unresolved-name>
   //              ::= pt <expression> <unresolved-name>
   if (base)
@@ -4981,9 +4985,11 @@
   case Expr::MemberExprClass: {
     NotPrimaryExpr();
     const MemberExpr *ME = cast<MemberExpr>(E);
-    mangleMemberExpr(ME->getBase(), ME->isArrow(), ME->getQualifier(),
-                     std::nullopt, ME->getMemberDecl()->getDeclName(),
-                     ME->getTemplateArgs(), ME->getNumTemplateArgs(), Arity);
+    mangleMemberExpr(ME->getBase(), ME->isArrow(),
+                     ME->getQualifier(), nullptr,
+                     ME->getMemberDecl()->getDeclName(),
+                     ME->getTemplateArgs(), ME->getNumTemplateArgs(),
+                     Arity);
     break;
   }
 
@@ -4991,9 +4997,10 @@
     NotPrimaryExpr();
     const UnresolvedMemberExpr *ME = cast<UnresolvedMemberExpr>(E);
     mangleMemberExpr(ME->isImplicitAccess() ? nullptr : ME->getBase(),
-                     ME->isArrow(), ME->getQualifier(), std::nullopt,
-                     ME->getMemberName(), ME->getTemplateArgs(),
-                     ME->getNumTemplateArgs(), Arity);
+                     ME->isArrow(), ME->getQualifier(), nullptr,
+                     ME->getMemberName(),
+                     ME->getTemplateArgs(), ME->getNumTemplateArgs(),
+                     Arity);
     break;
   }
 
@@ -5003,8 +5010,10 @@
       = cast<CXXDependentScopeMemberExpr>(E);
     mangleMemberExpr(ME->isImplicitAccess() ? nullptr : ME->getBase(),
                      ME->isArrow(), ME->getQualifier(),
-                     ME->unqualified_lookups(), ME->getMember(),
-                     ME->getTemplateArgs(), ME->getNumTemplateArgs(), Arity);
+                     ME->getFirstQualifierFoundInScope(),
+                     ME->getMember(),
+                     ME->getTemplateArgs(), ME->getNumTemplateArgs(),
+                     Arity);
     break;
   }
 
diff -ruN --strip-trailing-cr a/clang/lib/Parse/ParseExpr.cpp b/clang/lib/Parse/ParseExpr.cpp
--- a/clang/lib/Parse/ParseExpr.cpp
+++ b/clang/lib/Parse/ParseExpr.cpp
@@ -2343,9 +2343,10 @@
       }
 
       if (!LHS.isInvalid())
-        LHS = Actions.ActOnMemberAccessExpr(
-            getCurScope(), LHS.get(), OpLoc, OpKind, SS, TemplateKWLoc, Name,
-            CurParsedObjCImpl ? CurParsedObjCImpl->Dcl : nullptr);
+        LHS = Actions.ActOnMemberAccessExpr(getCurScope(), LHS.get(), OpLoc,
+                                            OpKind, SS, TemplateKWLoc, Name,
+                                 CurParsedObjCImpl ? CurParsedObjCImpl->Dcl
+                                                   : nullptr);
       if (!LHS.isInvalid()) {
         if (Tok.is(tok::less))
           checkPotentialAngleBracket(LHS);
diff -ruN --strip-trailing-cr a/clang/lib/Parse/ParseExprCXX.cpp b/clang/lib/Parse/ParseExprCXX.cpp
--- a/clang/lib/Parse/ParseExprCXX.cpp
+++ b/clang/lib/Parse/ParseExprCXX.cpp
@@ -100,8 +100,7 @@
   bool MemberOfUnknownSpecialization;
   if (!Actions.isTemplateName(getCurScope(), SS, /*hasTemplateKeyword=*/false,
                               TemplateName, ObjectType, EnteringContext,
-                              Template, MemberOfUnknownSpecialization,
-                              /*Disambiguation=*/false, /*MayBeNNS=*/true))
+                              Template, MemberOfUnknownSpecialization))
     return;
 
   FixDigraph(*this, PP, Next, SecondToken, tok::unknown,
@@ -354,8 +353,7 @@
       TemplateTy Template;
       TemplateNameKind TNK = Actions.ActOnTemplateName(
           getCurScope(), SS, TemplateKWLoc, TemplateName, ObjectType,
-          EnteringContext, Template, /*AllowInjectedClassName*/ true,
-          /*MayBeNNS=*/true);
+          EnteringContext, Template, /*AllowInjectedClassName*/ true);
       if (AnnotateTemplateIdToken(Template, TNK, SS, TemplateKWLoc,
                                   TemplateName, false))
         return true;
@@ -407,6 +405,7 @@
                                       : TemplateId->TemplateNameLoc;
         SS.SetInvalid(SourceRange(StartLoc, CCLoc));
       }
+
       continue;
     }
 
@@ -529,19 +528,18 @@
       UnqualifiedId TemplateName;
       TemplateName.setIdentifier(&II, Tok.getLocation());
       bool MemberOfUnknownSpecialization;
-      if (TemplateNameKind TNK = Actions.isTemplateName(
-              getCurScope(), SS,
-              /*hasTemplateKeyword=*/false, TemplateName, ObjectType,
-              EnteringContext, Template, MemberOfUnknownSpecialization,
-              /*Disambiguation=*/false,
-              /*MayBeNNS=*/true)) {
+      if (TemplateNameKind TNK = Actions.isTemplateName(getCurScope(), SS,
+                                              /*hasTemplateKeyword=*/false,
+                                                        TemplateName,
+                                                        ObjectType,
+                                                        EnteringContext,
+                                                        Template,
+                                              MemberOfUnknownSpecialization)) {
         // If lookup didn't find anything, we treat the name as a template-name
         // anyway. C++20 requires this, and in prior language modes it improves
         // error recovery. But before we commit to this, check that we actually
         // have something that looks like a template-argument-list next.
-        if (!IsTypename &&
-            (TNK == TNK_Undeclared_template ||
-             (!HasScopeSpecifier && ObjectType)) &&
+        if (!IsTypename && TNK == TNK_Undeclared_template &&
             isTemplateArgumentList(1) == TPResult::False)
           break;
 
@@ -568,7 +566,11 @@
           // member of an unknown specialization. However, this will only
           // parse correctly as a template, so suggest the keyword 'template'
           // before 'getAs' and treat this as a dependent template name.
-          Diag(Tok.getLocation(), diag::ext_missing_dependent_template_keyword)
+          unsigned DiagID = diag::err_missing_dependent_template_keyword;
+          if (getLangOpts().MicrosoftExt)
+            DiagID = diag::warn_missing_dependent_template_keyword;
+
+          Diag(Tok.getLocation(), DiagID)
               << II.getName()
               << FixItHint::CreateInsertion(Tok.getLocation(), "template ");
         }
@@ -1918,12 +1920,12 @@
   // argument list. This affects examples such as
   //   void f(auto *p) { p->~X<int>(); }
   // ... but there's no ambiguity, and nowhere to write 'template' in such an
-  // example, so we accept it anyway
-  if (Tok.is(tok::less) && ParseUnqualifiedIdTemplateId(
-                               SS, ObjectType, Base && Base->containsErrors(),
-                               /*TemplateKWLoc=*/SourceLocation(), TildeLoc,
-                               Name, NameLoc, false, SecondTypeName,
-                               /*AssumeTemplateId=*/true))
+  // example, so we accept it anyway.
+  if (Tok.is(tok::less) &&
+      ParseUnqualifiedIdTemplateId(
+          SS, ObjectType, Base && Base->containsErrors(), SourceLocation(),
+          Name, NameLoc, false, SecondTypeName,
+          /*AssumeTemplateId=*/true))
     return ExprError();
 
   return Actions.ActOnPseudoDestructorExpr(getCurScope(), Base, OpLoc, OpKind,
@@ -2530,9 +2532,8 @@
 /// \returns true if a parse error occurred, false otherwise.
 bool Parser::ParseUnqualifiedIdTemplateId(
     CXXScopeSpec &SS, ParsedType ObjectType, bool ObjectHadErrors,
-    SourceLocation TemplateKWLoc, SourceLocation TildeLoc, IdentifierInfo *Name,
-    SourceLocation NameLoc, bool EnteringContext, UnqualifiedId &Id,
-    bool AssumeTemplateId) {
+    SourceLocation TemplateKWLoc, IdentifierInfo *Name, SourceLocation NameLoc,
+    bool EnteringContext, UnqualifiedId &Id, bool AssumeTemplateId) {
   assert(Tok.is(tok::less) && "Expected '<' to finish parsing a template-id");
 
   TemplateTy Template;
@@ -2546,14 +2547,13 @@
       // this template-id is used to form a nested-name-specifier or not.
       TNK = Actions.ActOnTemplateName(getCurScope(), SS, TemplateKWLoc, Id,
                                       ObjectType, EnteringContext, Template,
-                                      /*AllowInjectedClassName=*/true,
-                                      TildeLoc.isValid());
+                                      /*AllowInjectedClassName*/ true);
     } else {
       bool MemberOfUnknownSpecialization;
-      TNK = Actions.isTemplateName(
-          getCurScope(), SS, TemplateKWLoc.isValid(), Id, ObjectType,
-          EnteringContext, Template, MemberOfUnknownSpecialization,
-          /*Disambiguation=*/false, TildeLoc.isValid());
+      TNK = Actions.isTemplateName(getCurScope(), SS,
+                                   TemplateKWLoc.isValid(), Id,
+                                   ObjectType, EnteringContext, Template,
+                                   MemberOfUnknownSpecialization);
       // If lookup found nothing but we're assuming that this is a template
       // name, double-check that makes sense syntactically before committing
       // to it.
@@ -2580,13 +2580,13 @@
             else
               Name += Id.Identifier->getName();
           }
-          Diag(Id.StartLocation, diag::ext_missing_dependent_template_keyword)
+          Diag(Id.StartLocation, diag::err_missing_dependent_template_keyword)
               << Name
               << FixItHint::CreateInsertion(Id.StartLocation, "template ");
         }
         TNK = Actions.ActOnTemplateName(
             getCurScope(), SS, TemplateKWLoc, Id, ObjectType, EnteringContext,
-            Template, /*AllowInjectedClassName=*/true, TildeLoc.isValid());
+            Template, /*AllowInjectedClassName*/ true);
       } else if (TNK == TNK_Non_template) {
         return false;
       }
@@ -2611,16 +2611,14 @@
     bool MemberOfUnknownSpecialization;
     TemplateName.setIdentifier(Name, NameLoc);
     if (ObjectType) {
-      TNK = Actions.ActOnTemplateName(getCurScope(), SS, TemplateKWLoc,
-                                      TemplateName, ObjectType, EnteringContext,
-                                      Template, /*AllowInjectedClassName=*/true,
-                                      /*MayBeNNS=*/true);
+      TNK = Actions.ActOnTemplateName(
+          getCurScope(), SS, TemplateKWLoc, TemplateName, ObjectType,
+          EnteringContext, Template, /*AllowInjectedClassName*/ true);
     } else {
       TNK = Actions.isTemplateName(getCurScope(), SS, TemplateKWLoc.isValid(),
-                                   TemplateName, ObjectType, EnteringContext,
-                                   Template, MemberOfUnknownSpecialization,
-                                   /*Disambiguation=*/false,
-                                   /*MayBeNNS=*/true);
+                                   TemplateName, ObjectType,
+                                   EnteringContext, Template,
+                                   MemberOfUnknownSpecialization);
 
       if (TNK == TNK_Non_template && !Id.DestructorName.get()) {
         Diag(NameLoc, diag::err_destructor_template_id)
@@ -2682,7 +2680,7 @@
   if (Id.getKind() == UnqualifiedIdKind::IK_ConstructorName)
     Id.setConstructorName(Type.get(), NameLoc, RAngleLoc);
   else
-    Id.setDestructorName(TildeLoc, Type.get(), RAngleLoc);
+    Id.setDestructorName(Id.StartLocation, Type.get(), RAngleLoc);
 
   return false;
 }
@@ -3030,9 +3028,8 @@
     if (Tok.is(tok::less))
       return ParseUnqualifiedIdTemplateId(
           SS, ObjectType, ObjectHadErrors,
-          TemplateKWLoc ? *TemplateKWLoc : SourceLocation(),
-          /*TildeLoc=*/SourceLocation(), Id, IdLoc, EnteringContext, Result,
-          TemplateSpecified);
+          TemplateKWLoc ? *TemplateKWLoc : SourceLocation(), Id, IdLoc,
+          EnteringContext, Result, TemplateSpecified);
 
     if (TemplateSpecified) {
       TemplateNameKind TNK =
@@ -3127,15 +3124,13 @@
         Tok.is(tok::less))
       return ParseUnqualifiedIdTemplateId(
           SS, ObjectType, ObjectHadErrors,
-          TemplateKWLoc ? *TemplateKWLoc : SourceLocation(),
-          /*TildeLoc=*/SourceLocation(), /*Name=*/nullptr,
-          /*NameLoc=*/SourceLocation(), EnteringContext, Result,
-          TemplateSpecified);
+          TemplateKWLoc ? *TemplateKWLoc : SourceLocation(), nullptr,
+          SourceLocation(), EnteringContext, Result, TemplateSpecified);
     else if (TemplateSpecified &&
              Actions.ActOnTemplateName(
                  getCurScope(), SS, *TemplateKWLoc, Result, ObjectType,
                  EnteringContext, Template,
-                 /*AllowInjectedClassName=*/true) == TNK_Non_template)
+                 /*AllowInjectedClassName*/ true) == TNK_Non_template)
       return true;
 
     return false;
@@ -3225,8 +3220,8 @@
       Result.setDestructorName(TildeLoc, nullptr, ClassNameLoc);
       return ParseUnqualifiedIdTemplateId(
           SS, ObjectType, ObjectHadErrors,
-          TemplateKWLoc ? *TemplateKWLoc : SourceLocation(), TildeLoc,
-          ClassName, ClassNameLoc, EnteringContext, Result, TemplateSpecified);
+          TemplateKWLoc ? *TemplateKWLoc : SourceLocation(), ClassName,
+          ClassNameLoc, EnteringContext, Result, TemplateSpecified);
     }
 
     // Note that this is a destructor name.
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaCXXScopeSpec.cpp b/clang/lib/Sema/SemaCXXScopeSpec.cpp
--- a/clang/lib/Sema/SemaCXXScopeSpec.cpp
+++ b/clang/lib/Sema/SemaCXXScopeSpec.cpp
@@ -356,41 +356,29 @@
   return false;
 }
 
-/// If the given nested-name-specifier begins with a bare identifier
-/// (e.g., Base::), perform name lookup for that identifier as a
-/// nested-name-specifier within the given scope, and return the result of that
-/// name lookup.
-bool Sema::LookupFirstQualifierInScope(Scope *S, NestedNameSpecifier *NNS,
-                                       UnresolvedSetImpl &R) {
-  if (!S)
-    return false;
+NamedDecl *Sema::FindFirstQualifierInScope(Scope *S, NestedNameSpecifier *NNS) {
+  if (!S || !NNS)
+    return nullptr;
 
   while (NNS->getPrefix())
     NNS = NNS->getPrefix();
 
-  // FIXME: This is a rather nasty hack! Ideally we should get the results
-  // from LookupTemplateName/BuildCXXNestedNameSpecifier.
-  const IdentifierInfo *II = NNS->getAsIdentifier();
-  if (!II) {
-    if (const auto *DTST =
-            dyn_cast_if_present<DependentTemplateSpecializationType>(
-                NNS->getAsType()))
-      II = DTST->getIdentifier();
-    else
-      return false;
-  }
-  assert(II && "Missing first qualifier in scope");
-  LookupResult Found(*this, II, SourceLocation(),
-                     NNS->getAsIdentifier() ? LookupNestedNameSpecifierName
-                                            : LookupOrdinaryName);
+  if (NNS->getKind() != NestedNameSpecifier::Identifier)
+    return nullptr;
+
+  LookupResult Found(*this, NNS->getAsIdentifier(), SourceLocation(),
+                     LookupNestedNameSpecifierName);
   LookupName(Found, S);
+  assert(!Found.isAmbiguous() && "Cannot handle ambiguities here yet");
 
-  if (Found.empty())
-    return false;
+  if (!Found.isSingleResult())
+    return nullptr;
 
-  R.addAllDecls(Found.asUnresolvedSet().pairs());
-  Found.suppressDiagnostics();
-  return true;
+  NamedDecl *Result = Found.getFoundDecl();
+  if (isAcceptableNestedNameSpecifier(Result))
+    return Result;
+
+  return nullptr;
 }
 
 namespace {
@@ -419,82 +407,112 @@
 
 bool Sema::BuildCXXNestedNameSpecifier(Scope *S, NestedNameSpecInfo &IdInfo,
                                        bool EnteringContext, CXXScopeSpec &SS,
+                                       NamedDecl *ScopeLookupResult,
                                        bool ErrorRecoveryLookup,
                                        bool *IsCorrectedToColon,
                                        bool OnlyNamespace) {
   if (IdInfo.Identifier->isEditorPlaceholder())
     return true;
-  if (IsCorrectedToColon)
-    *IsCorrectedToColon = false;
-
-  QualType ObjectType = GetTypeFromParser(IdInfo.ObjectType);
   LookupResult Found(*this, IdInfo.Identifier, IdInfo.IdentifierLoc,
                      OnlyNamespace ? LookupNamespaceName
                                    : LookupNestedNameSpecifierName);
+  QualType ObjectType = GetTypeFromParser(IdInfo.ObjectType);
 
-  // C++ [basic.lookup.qual.general]p3:
-  //   Qualified name lookup in a class, namespace, or enumeration performs a
-  //   search of the scope associated with it except as specified below.
-  LookupParsedName(Found, S, &SS, ObjectType,
-                   /*AllowBuiltinCreation=*/false, EnteringContext);
-
-  // C++ [basic.lookup.qual.general]p3:
-  //   [...] Unless otherwise specified, a qualified name undergoes qualified
-  //   name lookup in its lookup context from the point where it appears unless
-  //   the lookup context either is dependent and is not the current
-  //   instantiation or is not a class or class template.
-  if (Found.wasNotFoundInCurrentInstantiation()) {
-    // Don't speculate if we're just trying to improve error recovery.
-    if (ErrorRecoveryLookup)
-      return true;
-
-    // The lookup context is dependent and either:
-    // - it is not the current instantiation, or
-    // - it is the current instantiation, it has at least one dependent base
-    //   class, and qualified lookup found nothing.
-    // Build a dependent nested-name-specifier. We will lookup the name again
-    // during instantiation.
-    SS.Extend(Context, IdInfo.Identifier, IdInfo.IdentifierLoc, IdInfo.CCLoc);
-    return false;
+  // Determine where to perform name lookup
+  DeclContext *LookupCtx = nullptr;
+  bool isDependent = false;
+  if (IsCorrectedToColon)
+    *IsCorrectedToColon = false;
+  if (!ObjectType.isNull()) {
+    // This nested-name-specifier occurs in a member access expression, e.g.,
+    // x->B::f, and we are looking into the type of the object.
+    assert(!SS.isSet() && "ObjectType and scope specifier cannot coexist");
+    LookupCtx = computeDeclContext(ObjectType);
+    isDependent = ObjectType->isDependentType();
+  } else if (SS.isSet()) {
+    // This nested-name-specifier occurs after another nested-name-specifier,
+    // so look into the context associated with the prior nested-name-specifier.
+    LookupCtx = computeDeclContext(SS, EnteringContext);
+    isDependent = isDependentScopeSpecifier(SS);
+    Found.setContextRange(SS.getRange());
   }
 
   bool ObjectTypeSearchedInScope = false;
+  if (LookupCtx) {
+    // Perform "qualified" name lookup into the declaration context we
+    // computed, which is either the type of the base of a member access
+    // expression or the declaration context associated with a prior
+    // nested-name-specifier.
+
+    // The declaration context must be complete.
+    if (!LookupCtx->isDependentContext() &&
+        RequireCompleteDeclContext(SS, LookupCtx))
+      return true;
 
-  // C++ [basic.lookup.qual.general]p2:
-  //   A member-qualified name is the (unique) component name, if any, of
-  //   - an unqualified-id or
-  //   - a nested-name-specifier of the form type-name :: or namespace-name ::
-  //   in the id-expression of a class member access expression.
-  //
-  // C++ [basic.lookup.qual.general]p3:
-  //   [...] If nothing is found by qualified lookup for a member-qualified
-  //   name that is the terminal name of a nested-name-specifier and is not
-  //   dependent, it undergoes unqualified lookup.
-  //
-  // In 'x.A::B::y', 'A' will undergo unqualified lookup if qualified lookup
-  // in the type of 'x' finds nothing. If the lookup context is dependent,
-  // we perform the unqualified lookup in the template definition context
-  // and store the results so we can replicate the lookup during instantiation.
-  if (Found.empty() && !ObjectType.isNull()) {
-    if (S) {
-      LookupName(Found, S);
-    } else if (!SS.getUnqualifiedLookups().empty()) {
-      Found.addAllDecls(SS.getUnqualifiedLookups());
-      Found.resolveKind();
+    LookupQualifiedName(Found, LookupCtx);
+
+    if (!ObjectType.isNull() && Found.empty()) {
+      // C++ [basic.lookup.classref]p4:
+      //   If the id-expression in a class member access is a qualified-id of
+      //   the form
+      //
+      //        class-name-or-namespace-name::...
+      //
+      //   the class-name-or-namespace-name following the . or -> operator is
+      //   looked up both in the context of the entire postfix-expression and in
+      //   the scope of the class of the object expression. If the name is found
+      //   only in the scope of the class of the object expression, the name
+      //   shall refer to a class-name. If the name is found only in the
+      //   context of the entire postfix-expression, the name shall refer to a
+      //   class-name or namespace-name. [...]
+      //
+      // Qualified name lookup into a class will not find a namespace-name,
+      // so we do not need to diagnose that case specifically. However,
+      // this qualified name lookup may find nothing. In that case, perform
+      // unqualified name lookup in the given scope (if available) or
+      // reconstruct the result from when name lookup was performed at template
+      // definition time.
+      if (S)
+        LookupName(Found, S);
+      else if (ScopeLookupResult)
+        Found.addDecl(ScopeLookupResult);
+
+      ObjectTypeSearchedInScope = true;
     }
-    ObjectTypeSearchedInScope = true;
+  } else if (!isDependent) {
+    // Perform unqualified name lookup in the current scope.
+    LookupName(Found, S);
   }
 
   if (Found.isAmbiguous())
     return true;
 
+  // If we performed lookup into a dependent context and did not find anything,
+  // that's fine: just build a dependent nested-name-specifier.
+  if (Found.empty() && isDependent &&
+      !(LookupCtx && LookupCtx->isRecord() &&
+        (!cast<CXXRecordDecl>(LookupCtx)->hasDefinition() ||
+         !cast<CXXRecordDecl>(LookupCtx)->hasAnyDependentBases()))) {
+    // Don't speculate if we're just trying to improve error recovery.
+    if (ErrorRecoveryLookup)
+      return true;
+
+    // We were not able to compute the declaration context for a dependent
+    // base object type or prior nested-name-specifier, so this
+    // nested-name-specifier refers to an unknown specialization. Just build
+    // a dependent nested-name-specifier.
+    SS.Extend(Context, IdInfo.Identifier, IdInfo.IdentifierLoc, IdInfo.CCLoc);
+    return false;
+  }
+
   if (Found.empty() && !ErrorRecoveryLookup) {
     // If identifier is not found as class-name-or-namespace-name, but is found
     // as other entity, don't look for typos.
     LookupResult R(*this, Found.getLookupNameInfo(), LookupOrdinaryName);
-    LookupParsedName(R, S, &SS, ObjectType,
-                     /*AllowBuiltinCreation=*/false, EnteringContext);
-
+    if (LookupCtx)
+      LookupQualifiedName(R, LookupCtx);
+    else if (S && !isDependent)
+      LookupName(R, S);
     if (!R.empty()) {
       // Don't diagnose problems with this speculative lookup.
       R.suppressDiagnostics();
@@ -521,11 +539,6 @@
     }
   }
 
-  DeclContext *LookupCtx =
-      SS.isSet()
-          ? computeDeclContext(SS, EnteringContext)
-          : (!ObjectType.isNull() ? computeDeclContext(ObjectType) : nullptr);
-
   if (Found.empty() && !ErrorRecoveryLookup && !getLangOpts().MSVCCompat) {
     // We haven't found anything, and we're not recovering from a
     // different kind of error, so look for typos.
@@ -581,14 +594,14 @@
       // scope, reconstruct the result from the template instantiation itself.
       //
       // Note that C++11 does *not* perform this redundant lookup.
-      NamedDecl *OuterDecl = nullptr;
+      NamedDecl *OuterDecl;
       if (S) {
         LookupResult FoundOuter(*this, IdInfo.Identifier, IdInfo.IdentifierLoc,
                                 LookupNestedNameSpecifierName);
         LookupName(FoundOuter, S);
         OuterDecl = FoundOuter.getAsSingle<NamedDecl>();
-      } else if (!SS.getUnqualifiedLookups().empty())
-        OuterDecl = SS.getUnqualifiedLookups().front().getDecl();
+      } else
+        OuterDecl = ScopeLookupResult;
 
       if (isAcceptableNestedNameSpecifier(OuterDecl) &&
           OuterDecl->getCanonicalDecl() != SD->getCanonicalDecl() &&
@@ -766,7 +779,7 @@
     return true;
 
   return BuildCXXNestedNameSpecifier(S, IdInfo, EnteringContext, SS,
-                                     /*ErrorRecoveryLookup=*/false,
+                                     /*ScopeLookupResult=*/nullptr, false,
                                      IsCorrectedToColon, OnlyNamespace);
 }
 
@@ -827,7 +840,7 @@
     return false;
 
   return !BuildCXXNestedNameSpecifier(S, IdInfo, EnteringContext, SS,
-                                      /*ErrorRecoveryLookup=*/true);
+                                      /*ScopeLookupResult=*/nullptr, true);
 }
 
 bool Sema::ActOnCXXNestedNameSpecifier(Scope *S,
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaCoroutine.cpp b/clang/lib/Sema/SemaCoroutine.cpp
--- a/clang/lib/Sema/SemaCoroutine.cpp
+++ b/clang/lib/Sema/SemaCoroutine.cpp
@@ -306,8 +306,8 @@
   // FIXME: Fix BuildMemberReferenceExpr to take a const CXXScopeSpec&.
   CXXScopeSpec SS;
   ExprResult Result = S.BuildMemberReferenceExpr(
-      Base, Base->getType(), Loc, /*IsPtr=*/false, SS, SourceLocation(),
-      NameInfo, /*TemplateArgs=*/nullptr,
+      Base, Base->getType(), Loc, /*IsPtr=*/false, SS,
+      SourceLocation(), nullptr, NameInfo, /*TemplateArgs=*/nullptr,
       /*Scope=*/nullptr);
   if (Result.isInvalid())
     return ExprError();
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDecl.cpp b/clang/lib/Sema/SemaDecl.cpp
--- a/clang/lib/Sema/SemaDecl.cpp
+++ b/clang/lib/Sema/SemaDecl.cpp
@@ -15934,8 +15934,6 @@
         }
       }
 
-      DiagnoseMissingFormatAttributes(Body, FD);
-
       // We might not have found a prototype because we didn't wish to warn on
       // the lack of a missing prototype. Try again without the checks for
       // whether we want to warn on the missing prototype.
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDeclAttr.cpp b/clang/lib/Sema/SemaDeclAttr.cpp
--- a/clang/lib/Sema/SemaDeclAttr.cpp
+++ b/clang/lib/Sema/SemaDeclAttr.cpp
@@ -3508,7 +3508,7 @@
 
   // In C++ the implicit 'this' function parameter also counts, and they are
   // counted from one.
-  bool HasImplicitThisParam = checkIfMethodHasImplicitObjectParameter(D);
+  bool HasImplicitThisParam = isInstanceMethod(D);
   unsigned NumArgs = getFunctionOrMethodNumParams(D) + HasImplicitThisParam;
 
   IdentifierInfo *II = AL.getArgAsIdent(0)->Ident;
@@ -3621,7 +3621,7 @@
     return;
   }
 
-  bool HasImplicitThisParam = checkIfMethodHasImplicitObjectParameter(D);
+  bool HasImplicitThisParam = isInstanceMethod(D);
   int32_t NumArgs = getFunctionOrMethodNumParams(D);
 
   FunctionDecl *FD = D->getAsFunction();
@@ -5320,221 +5320,6 @@
   D->addAttr(::new (S.Context) PreferredTypeAttr(S.Context, AL, ParmTSI));
 }
 
-// This function is called only if function call is not inside template body.
-// TODO: Add call for function calls inside template body.
-// Emit warnings if parent function misses format attributes.
-void Sema::DiagnoseMissingFormatAttributes(Stmt *Body,
-                                           const FunctionDecl *FDecl) {
-  assert(FDecl);
-
-  // If there are no function body, exit.
-  if (!Body)
-    return;
-
-  // Get missing format attributes
-  std::vector<FormatAttr *> MissingFormatAttributes =
-      GetMissingFormatAttributes(Body, FDecl);
-  if (MissingFormatAttributes.empty())
-    return;
-
-  // Check if there are more than one format type found. In that case do not
-  // emit diagnostic.
-  const FormatAttr *FirstAttr = MissingFormatAttributes[0];
-  if (llvm::any_of(MissingFormatAttributes, [&](const FormatAttr *Attr) {
-        return FirstAttr->getType() != Attr->getType();
-      }))
-    return;
-
-  for (const FormatAttr *FA : MissingFormatAttributes) {
-    // If format index and first-to-check argument index are negative, it means
-    // that this attribute is only saved for multiple format types checking.
-    if (FA->getFormatIdx() < 0 || FA->getFirstArg() < 0)
-      continue;
-
-    // Emit diagnostic
-    SourceLocation Loc = FDecl->getLocation();
-    Diag(Loc, diag::warn_missing_format_attribute)
-        << FA->getType() << FDecl
-        << FixItHint::CreateInsertion(Loc,
-                                      (llvm::Twine("__attribute__((format(") +
-                                       FA->getType()->getName() + ", " +
-                                       llvm::Twine(FA->getFormatIdx()) + ", " +
-                                       llvm::Twine(FA->getFirstArg()) + ")))")
-                                          .str());
-  }
-}
-
-// Returns vector of format attributes. There are no two attributes with same
-// arguments in returning vector. There can be attributes that effectivelly only
-// store information about format type.
-std::vector<FormatAttr *>
-Sema::GetMissingFormatAttributes(Stmt *Body, const FunctionDecl *FDecl) {
-  unsigned int FunctionFormatArgumentIndexOffset =
-      checkIfMethodHasImplicitObjectParameter(FDecl) ? 2 : 1;
-
-  std::vector<FormatAttr *> MissingAttributes;
-
-  // Iterate over body statements.
-  for (auto *Child : Body->children()) {
-    // If child statement is compound statement, recursively get missing
-    // attributes.
-    if (dyn_cast_or_null<CompoundStmt>(Child)) {
-      std::vector<FormatAttr *> CompoundStmtMissingAttributes =
-          GetMissingFormatAttributes(Child, FDecl);
-
-      // If there are already missing attributes with same arguments, do not add
-      // duplicates.
-      for (FormatAttr *FA : CompoundStmtMissingAttributes) {
-        if (!llvm::any_of(MissingAttributes, [&](const FormatAttr *Attr) {
-              return FA->getType() == Attr->getType() &&
-                     FA->getFormatIdx() == Attr->getFormatIdx() &&
-                     FA->getFirstArg() == Attr->getFirstArg();
-            }))
-          MissingAttributes.push_back(FA);
-      }
-
-      continue;
-    }
-
-    ValueStmt *VS = dyn_cast_or_null<ValueStmt>(Child);
-    if (!VS)
-      continue;
-    Expr *TheExpr = VS->getExprStmt();
-    if (!TheExpr)
-      continue;
-    CallExpr *TheCall = dyn_cast_or_null<CallExpr>(TheExpr);
-    if (!TheCall)
-      continue;
-    const FunctionDecl *ChildFunction =
-        dyn_cast_or_null<FunctionDecl>(TheCall->getCalleeDecl());
-    if (!ChildFunction)
-      continue;
-
-    Expr **Args = TheCall->getArgs();
-    unsigned int NumArgs = TheCall->getNumArgs();
-
-    // If child expression is function, check if it is format function.
-    // If it is, check if parent function misses format attributes.
-
-    // If child function is format function and format arguments are not
-    // relevant to emit diagnostic, save only information about format type
-    // (format index and first-to-check argument index are set to -1).
-    // Information about format type is later used to determine if there are
-    // more than one format type found.
-
-    unsigned int ChildFunctionFormatArgumentIndexOffset =
-        checkIfMethodHasImplicitObjectParameter(ChildFunction) ? 2 : 1;
-
-    // Check if function has format attribute with forwarded format string.
-    IdentifierInfo *AttrType;
-    const ParmVarDecl *FormatArg;
-    if (!llvm::any_of(ChildFunction->specific_attrs<FormatAttr>(),
-                      [&](const FormatAttr *Attr) {
-                        AttrType = Attr->getType();
-
-                        int OffsetFormatIndex =
-                            Attr->getFormatIdx() -
-                            ChildFunctionFormatArgumentIndexOffset;
-                        if (OffsetFormatIndex < 0 ||
-                            (unsigned)OffsetFormatIndex >= NumArgs)
-                          return false;
-
-                        const auto *FormatArgExpr = dyn_cast<DeclRefExpr>(
-                            Args[OffsetFormatIndex]->IgnoreParenCasts());
-                        if (!FormatArgExpr)
-                          return false;
-
-                        FormatArg = dyn_cast_or_null<ParmVarDecl>(
-                            FormatArgExpr->getReferencedDeclOfCallee());
-                        if (!FormatArg)
-                          return false;
-
-                        return true;
-                      })) {
-      MissingAttributes.push_back(
-          FormatAttr::CreateImplicit(getASTContext(), AttrType, -1, -1));
-      continue;
-    }
-
-    // Do not add in a vector format attributes whose type is different than
-    // parent function attribute type.
-    if (llvm::any_of(FDecl->specific_attrs<FormatAttr>(),
-                     [&](const FormatAttr *FunctionAttr) {
-                       return AttrType != FunctionAttr->getType();
-                     }))
-      continue;
-
-    // Check if format string argument is parent function parameter.
-    unsigned int StringIndex = 0;
-    if (!llvm::any_of(FDecl->parameters(), [&](const ParmVarDecl *Param) {
-          if (Param != FormatArg)
-            return false;
-
-          StringIndex = Param->getFunctionScopeIndex() +
-                        FunctionFormatArgumentIndexOffset;
-
-          return true;
-        })) {
-      MissingAttributes.push_back(
-          FormatAttr::CreateImplicit(getASTContext(), AttrType, -1, -1));
-      continue;
-    }
-
-    unsigned NumOfParentFunctionParams = FDecl->getNumParams();
-
-    // Compare parent and calling function format attribute arguments (archetype
-    // and format string).
-    if (llvm::any_of(
-            FDecl->specific_attrs<FormatAttr>(), [&](const FormatAttr *Attr) {
-              if (Attr->getType() != AttrType)
-                return false;
-              int OffsetFormatIndex =
-                  Attr->getFormatIdx() - FunctionFormatArgumentIndexOffset;
-
-              if (OffsetFormatIndex < 0 ||
-                  (unsigned)OffsetFormatIndex >= NumOfParentFunctionParams)
-                return false;
-
-              if (FDecl->parameters()[OffsetFormatIndex] != FormatArg)
-                return false;
-
-              return true;
-            })) {
-      MissingAttributes.push_back(
-          FormatAttr::CreateImplicit(getASTContext(), AttrType, -1, -1));
-      continue;
-    }
-
-    // Get first argument index
-    unsigned FirstToCheck = [&]() -> unsigned {
-      if (!FDecl->isVariadic())
-        return 0;
-      const auto *FirstToCheckArg =
-          dyn_cast<DeclRefExpr>(Args[NumArgs - 1]->IgnoreParenCasts());
-      if (!FirstToCheckArg)
-        return 0;
-
-      if (FirstToCheckArg->getType().getCanonicalType() !=
-          Context.getBuiltinVaListType().getCanonicalType())
-        return 0;
-      return NumOfParentFunctionParams + FunctionFormatArgumentIndexOffset;
-    }();
-
-    // If there are already attributes which arguments matches arguments
-    // detected in this iteration, do not add new attribute as it would be
-    // duplicate.
-    if (!llvm::any_of(MissingAttributes, [&](const FormatAttr *Attr) {
-          return Attr->getType() == AttrType &&
-                 Attr->getFormatIdx() == StringIndex &&
-                 Attr->getFirstArg() == FirstToCheck;
-        }))
-      MissingAttributes.push_back(FormatAttr::CreateImplicit(
-          getASTContext(), AttrType, StringIndex, FirstToCheck));
-  }
-
-  return MissingAttributes;
-}
-
 //===----------------------------------------------------------------------===//
 // Microsoft specific attribute handlers.
 //===----------------------------------------------------------------------===//
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDeclCXX.cpp b/clang/lib/Sema/SemaDeclCXX.cpp
--- a/clang/lib/Sema/SemaDeclCXX.cpp
+++ b/clang/lib/Sema/SemaDeclCXX.cpp
@@ -1275,11 +1275,9 @@
     if (UseMemberGet) {
       //   if [lookup of member get] finds at least one declaration, the
       //   initializer is e.get<i-1>().
-      E = S.BuildMemberReferenceExpr(E.get(), DecompType, Loc,
-                                     /*IsArrow=*/false,
-                                     /*SS=*/CXXScopeSpec(),
-                                     /*TemplateKWLoc=*/SourceLocation(),
-                                     MemberGet, &Args, /*S=*/nullptr);
+      E = S.BuildMemberReferenceExpr(E.get(), DecompType, Loc, false,
+                                     CXXScopeSpec(), SourceLocation(), nullptr,
+                                     MemberGet, &Args, nullptr);
       if (E.isInvalid())
         return true;
 
@@ -4903,12 +4901,16 @@
     MemberLookup.addDecl(Indirect ? cast<ValueDecl>(Indirect)
                                   : cast<ValueDecl>(Field), AS_public);
     MemberLookup.resolveKind();
-    ExprResult CtorArg = SemaRef.BuildMemberReferenceExpr(
-        MemberExprBase, ParamType, Loc,
-        /*IsArrow=*/false, SS,
-        /*TemplateKWLoc=*/SourceLocation(), MemberLookup,
-        /*TemplateArgs=*/nullptr,
-        /*S=*/nullptr);
+    ExprResult CtorArg
+      = SemaRef.BuildMemberReferenceExpr(MemberExprBase,
+                                         ParamType, Loc,
+                                         /*IsArrow=*/false,
+                                         SS,
+                                         /*TemplateKWLoc=*/SourceLocation(),
+                                         /*FirstQualifierInScope=*/nullptr,
+                                         MemberLookup,
+                                         /*TemplateArgs=*/nullptr,
+                                         /*S*/nullptr);
     if (CtorArg.isInvalid())
       return true;
 
@@ -14334,10 +14336,8 @@
 public:
   Expr *build(Sema &S, SourceLocation Loc) const override {
     return assertNotNull(S.BuildMemberReferenceExpr(
-                              Builder.build(S, Loc), Type, Loc, IsArrow, SS,
-                              /*TemplateKwLoc=*/SourceLocation(), MemberLookup,
-                              /*TemplateArgs=*/nullptr, /*S=*/nullptr)
-                             .get());
+        Builder.build(S, Loc), Type, Loc, IsArrow, SS, SourceLocation(),
+        nullptr, MemberLookup, nullptr, nullptr).get());
   }
 
   MemberBuilder(const ExprBuilder &Builder, QualType Type, bool IsArrow,
@@ -14543,11 +14543,13 @@
                    Loc);
 
     // Create the reference to operator=.
-    ExprResult OpEqualRef = S.BuildMemberReferenceExpr(
-        To.build(S, Loc), T, Loc, /*IsArrow=*/false, SS,
-        /*TemplateKWLoc=*/SourceLocation(), OpLookup,
-        /*TemplateArgs=*/nullptr, /*S*/ nullptr,
-        /*SuppressQualifierCheck=*/true);
+    ExprResult OpEqualRef
+      = S.BuildMemberReferenceExpr(To.build(S, Loc), T, Loc, /*IsArrow=*/false,
+                                   SS, /*TemplateKWLoc=*/SourceLocation(),
+                                   /*FirstQualifierInScope=*/nullptr,
+                                   OpLookup,
+                                   /*TemplateArgs=*/nullptr, /*S*/nullptr,
+                                   /*SuppressQualifierCheck=*/true);
     if (OpEqualRef.isInvalid())
       return StmtError();
 
@@ -17153,9 +17155,8 @@
 
   auto BuildExpr = [&](LookupResult &LR) {
     ExprResult Res = BuildMemberReferenceExpr(
-        Message, Message->getType(), Message->getBeginLoc(), /*IsArrow=*/false,
-        /*SS=*/CXXScopeSpec(), /*TemplateKWLoc=*/SourceLocation(), LR,
-        /*TemplateArgs=*/nullptr, /*S=*/nullptr);
+        Message, Message->getType(), Message->getBeginLoc(), false,
+        CXXScopeSpec(), SourceLocation(), nullptr, LR, nullptr, nullptr);
     if (Res.isInvalid())
       return ExprError();
     Res = BuildCallExpr(nullptr, Res.get(), Loc, std::nullopt, Loc, nullptr,
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaExpr.cpp b/clang/lib/Sema/SemaExpr.cpp
--- a/clang/lib/Sema/SemaExpr.cpp
+++ b/clang/lib/Sema/SemaExpr.cpp
@@ -2624,7 +2624,7 @@
     return CXXDependentScopeMemberExpr::Create(
         Context, /*This=*/nullptr, ThisType, /*IsArrow=*/true,
         /*Op=*/SourceLocation(), NestedNameSpecifierLoc(), TemplateKWLoc,
-        /*UnqualifiedLookups=*/std::nullopt, NameInfo, TemplateArgs);
+        /*FirstQualifierFoundInScope=*/nullptr, NameInfo, TemplateArgs);
   }
 
   // Synthesize a fake NNS that points to the derived class.  This will
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaExprMember.cpp b/clang/lib/Sema/SemaExprMember.cpp
--- a/clang/lib/Sema/SemaExprMember.cpp
+++ b/clang/lib/Sema/SemaExprMember.cpp
@@ -552,9 +552,11 @@
 }
 
 ExprResult
-Sema::ActOnDependentMemberExpr(Expr *BaseExpr, QualType BaseType, bool IsArrow,
-                               SourceLocation OpLoc, const CXXScopeSpec &SS,
+Sema::ActOnDependentMemberExpr(Expr *BaseExpr, QualType BaseType,
+                               bool IsArrow, SourceLocation OpLoc,
+                               const CXXScopeSpec &SS,
                                SourceLocation TemplateKWLoc,
+                               NamedDecl *FirstQualifierInScope,
                                const DeclarationNameInfo &NameInfo,
                                const TemplateArgumentListInfo *TemplateArgs) {
   // Even in dependent contexts, try to diagnose base expressions with
@@ -588,8 +590,8 @@
   // must have pointer type, and the accessed type is the pointee.
   return CXXDependentScopeMemberExpr::Create(
       Context, BaseExpr, BaseType, IsArrow, OpLoc,
-      SS.getWithLocInContext(Context), TemplateKWLoc,
-      SS.getUnqualifiedLookups(), NameInfo, TemplateArgs);
+      SS.getWithLocInContext(Context), TemplateKWLoc, FirstQualifierInScope,
+      NameInfo, TemplateArgs);
 }
 
 /// We know that the given qualified member reference points only to
@@ -765,9 +767,8 @@
           R.addDecl(ND);
         R.resolveKind();
         return SemaRef.BuildMemberReferenceExpr(
-            BaseExpr, BaseExpr->getType(), OpLoc, IsArrow, SS,
-            /*TemplateKWLoc=*/SourceLocation(), R, /*TemplateArgs=*/nullptr,
-            /*S=*/nullptr);
+            BaseExpr, BaseExpr->getType(), OpLoc, IsArrow, SS, SourceLocation(),
+            nullptr, R, nullptr, nullptr);
       },
       Sema::CTK_ErrorRecovery, DC);
 
@@ -783,7 +784,7 @@
 ExprResult Sema::BuildMemberReferenceExpr(
     Expr *Base, QualType BaseType, SourceLocation OpLoc, bool IsArrow,
     CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
-    const DeclarationNameInfo &NameInfo,
+    NamedDecl *FirstQualifierInScope, const DeclarationNameInfo &NameInfo,
     const TemplateArgumentListInfo *TemplateArgs, const Scope *S,
     ActOnMemberAccessExtraArgs *ExtraArgs) {
   LookupResult R(*this, NameInfo, LookupMemberName);
@@ -827,9 +828,10 @@
   if (SS.isInvalid())
     return ExprError();
 
-  return BuildMemberReferenceExpr(Base, BaseType, OpLoc, IsArrow, SS,
-                                  TemplateKWLoc, R, TemplateArgs, S,
-                                  /*SuppressQualifierCheck=*/false, ExtraArgs);
+  return BuildMemberReferenceExpr(Base, BaseType,
+                                  OpLoc, IsArrow, SS, TemplateKWLoc,
+                                  FirstQualifierInScope, R, TemplateArgs, S,
+                                  false, ExtraArgs);
 }
 
 ExprResult
@@ -967,11 +969,17 @@
   return false;
 }
 
-ExprResult Sema::BuildMemberReferenceExpr(
-    Expr *BaseExpr, QualType BaseExprType, SourceLocation OpLoc, bool IsArrow,
-    const CXXScopeSpec &SS, SourceLocation TemplateKWLoc, LookupResult &R,
-    const TemplateArgumentListInfo *TemplateArgs, const Scope *S,
-    bool SuppressQualifierCheck, ActOnMemberAccessExtraArgs *ExtraArgs) {
+ExprResult
+Sema::BuildMemberReferenceExpr(Expr *BaseExpr, QualType BaseExprType,
+                               SourceLocation OpLoc, bool IsArrow,
+                               const CXXScopeSpec &SS,
+                               SourceLocation TemplateKWLoc,
+                               NamedDecl *FirstQualifierInScope,
+                               LookupResult &R,
+                               const TemplateArgumentListInfo *TemplateArgs,
+                               const Scope *S,
+                               bool SuppressQualifierCheck,
+                               ActOnMemberAccessExtraArgs *ExtraArgs) {
   assert(!SS.isInvalid() && "nested-name-specifier cannot be invalid");
   // If the member wasn't found in the current instantiation, or if the
   // arrow operator was used with a dependent non-pointer object expression,
@@ -981,8 +989,8 @@
        (SS.isSet() ? SS.getScopeRep()->isDependent()
                    : BaseExprType->isDependentType())))
     return ActOnDependentMemberExpr(BaseExpr, BaseExprType, IsArrow, OpLoc, SS,
-                                    TemplateKWLoc, R.getLookupNameInfo(),
-                                    TemplateArgs);
+                                    TemplateKWLoc, FirstQualifierInScope,
+                                    R.getLookupNameInfo(), TemplateArgs);
 
   QualType BaseType = BaseExprType;
   if (IsArrow) {
@@ -1187,9 +1195,9 @@
 
     // Non-dependent member, but dependent template arguments.
     if (!VDecl.get())
-      return ActOnDependentMemberExpr(BaseExpr, BaseExpr->getType(), IsArrow,
-                                      OpLoc, SS, TemplateKWLoc, MemberNameInfo,
-                                      TemplateArgs);
+      return ActOnDependentMemberExpr(
+          BaseExpr, BaseExpr->getType(), IsArrow, OpLoc, SS, TemplateKWLoc,
+          FirstQualifierInScope, MemberNameInfo, TemplateArgs);
 
     VarDecl *Var = cast<VarDecl>(VDecl.get());
     if (!Var->getTemplateSpecializationKind())
@@ -1755,16 +1763,15 @@
   const TemplateArgumentListInfo *TemplateArgs;
   DecomposeUnqualifiedId(Id, TemplateArgsBuffer,
                          NameInfo, TemplateArgs);
-  bool IsArrow = OpKind == tok::arrow;
+
+  bool IsArrow = (OpKind == tok::arrow);
 
   if (getLangOpts().HLSL && IsArrow)
     return ExprError(Diag(OpLoc, diag::err_hlsl_operator_unsupported) << 2);
 
-  UnresolvedSet<4> UnqualifiedLookups;
-  if (SS.isValid() &&
-      LookupFirstQualifierInScope(S, SS.getScopeRep(), UnqualifiedLookups)) {
-    SS.setUnqualifiedLookups(UnqualifiedLookups.pairs());
-  }
+  NamedDecl *FirstQualifierInScope
+    = (!SS.isSet() ? nullptr : FindFirstQualifierInScope(S, SS.getScopeRep()));
+
   // This is a postfix expression, so get rid of ParenListExprs.
   ExprResult Result = MaybeConvertParenListExprToParenExpr(S, Base);
   if (Result.isInvalid()) return ExprError();
@@ -1772,8 +1779,8 @@
 
   ActOnMemberAccessExtraArgs ExtraArgs = {S, Id, ObjCImpDecl};
   ExprResult Res = BuildMemberReferenceExpr(
-      Base, Base->getType(), OpLoc, IsArrow, SS, TemplateKWLoc, NameInfo,
-      TemplateArgs, S, &ExtraArgs);
+      Base, Base->getType(), OpLoc, IsArrow, SS, TemplateKWLoc,
+      FirstQualifierInScope, NameInfo, TemplateArgs, S, &ExtraArgs);
 
   if (!Res.isInvalid() && isa<MemberExpr>(Res.get()))
     CheckMemberAccessOfNoDeref(cast<MemberExpr>(Res.get()));
@@ -1917,8 +1924,9 @@
     baseExpr = BuildCXXThisExpr(loc, ThisTy, /*IsImplicit=*/true);
   }
 
-  return BuildMemberReferenceExpr(baseExpr, ThisTy,
-                                  /*OpLoc=*/SourceLocation(),
-                                  /*IsArrow=*/!getLangOpts().HLSL, SS,
-                                  TemplateKWLoc, R, TemplateArgs, S);
+  return BuildMemberReferenceExpr(
+      baseExpr, ThisTy,
+      /*OpLoc=*/SourceLocation(),
+      /*IsArrow=*/!getLangOpts().HLSL, SS, TemplateKWLoc,
+      /*FirstQualifierInScope=*/nullptr, R, TemplateArgs, S);
 }
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaOverload.cpp b/clang/lib/Sema/SemaOverload.cpp
--- a/clang/lib/Sema/SemaOverload.cpp
+++ b/clang/lib/Sema/SemaOverload.cpp
@@ -16043,11 +16043,13 @@
 
   CandidateSet->clear(OverloadCandidateSet::CSK_Normal);
   if (!MemberLookup.empty()) {
-    ExprResult MemberRef = BuildMemberReferenceExpr(
-        Range, Range->getType(), Loc,
-        /*IsPtr=*/false, /*SS=*/CXXScopeSpec(),
-        /*TemplateKWLoc=*/SourceLocation(), MemberLookup,
-        /*TemplateArgs=*/nullptr, S);
+    ExprResult MemberRef =
+        BuildMemberReferenceExpr(Range, Range->getType(), Loc,
+                                 /*IsPtr=*/false, CXXScopeSpec(),
+                                 /*TemplateKWLoc=*/SourceLocation(),
+                                 /*FirstQualifierInScope=*/nullptr,
+                                 MemberLookup,
+                                 /*TemplateArgs=*/nullptr, S);
     if (MemberRef.isInvalid()) {
       *CallExpr = ExprError();
       return FRS_DiagnosticIssued;
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaStmtAsm.cpp b/clang/lib/Sema/SemaStmtAsm.cpp
--- a/clang/lib/Sema/SemaStmtAsm.cpp
+++ b/clang/lib/Sema/SemaStmtAsm.cpp
@@ -900,8 +900,7 @@
     return CXXDependentScopeMemberExpr::Create(
         Context, E, T, /*IsArrow=*/false, AsmLoc, NestedNameSpecifierLoc(),
         SourceLocation(),
-        /*UnqualifiedLookups=*/std::nullopt, NameInfo,
-        /*TemplateArgs=*/nullptr);
+        /*FirstQualifierFoundInScope=*/nullptr, NameInfo, /*TemplateArgs=*/nullptr);
   }
 
   const RecordType *RT = T->getAs<RecordType>();
@@ -924,9 +923,8 @@
 
   // Make an Expr to thread through OpDecl.
   ExprResult Result = BuildMemberReferenceExpr(
-      E, E->getType(), AsmLoc, /*IsArrow=*/false, /*SS=*/CXXScopeSpec(),
-      /*TemplateKWLoc*/ SourceLocation(), FieldResult,
-      /*TemplateArgs=*/nullptr, /*S=*/nullptr);
+      E, E->getType(), AsmLoc, /*IsArrow=*/false, CXXScopeSpec(),
+      SourceLocation(), nullptr, FieldResult, nullptr, nullptr);
 
   return Result;
 }
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaTemplate.cpp b/clang/lib/Sema/SemaTemplate.cpp
--- a/clang/lib/Sema/SemaTemplate.cpp
+++ b/clang/lib/Sema/SemaTemplate.cpp
@@ -174,12 +174,15 @@
   return false;
 }
 
-TemplateNameKind
-Sema::isTemplateName(Scope *S, CXXScopeSpec &SS, bool hasTemplateKeyword,
-                     const UnqualifiedId &Name, ParsedType ObjectTypePtr,
-                     bool EnteringContext, TemplateTy &TemplateResult,
-                     bool &MemberOfUnknownSpecialization, bool Disambiguation,
-                     bool MayBeNNS) {
+TemplateNameKind Sema::isTemplateName(Scope *S,
+                                      CXXScopeSpec &SS,
+                                      bool hasTemplateKeyword,
+                                      const UnqualifiedId &Name,
+                                      ParsedType ObjectTypePtr,
+                                      bool EnteringContext,
+                                      TemplateTy &TemplateResult,
+                                      bool &MemberOfUnknownSpecialization,
+                                      bool Disambiguation) {
   assert(getLangOpts().CPlusPlus && "No template names in C!");
 
   DeclarationName TName;
@@ -210,9 +213,8 @@
   if (LookupTemplateName(R, S, SS, ObjectType, EnteringContext,
                          /*RequiredTemplate=*/SourceLocation(),
                          &AssumedTemplate,
-                         /*AllowTypoCorrection=*/!Disambiguation, MayBeNNS))
+                         /*AllowTypoCorrection=*/!Disambiguation))
     return TNK_Non_template;
-
   MemberOfUnknownSpecialization = R.wasNotFoundInCurrentInstantiation();
 
   if (AssumedTemplate != AssumedTemplateKind::None) {
@@ -378,7 +380,7 @@
                               QualType ObjectType, bool EnteringContext,
                               RequiredTemplateKind RequiredTemplate,
                               AssumedTemplateKind *ATK,
-                              bool AllowTypoCorrection, bool MayBeNNS) {
+                              bool AllowTypoCorrection) {
   if (ATK)
     *ATK = AssumedTemplateKind::None;
 
@@ -387,89 +389,92 @@
 
   Found.setTemplateNameLookup(true);
 
-  // Template names cannot appear inside an Objective-C class or object type
-  // or a vector type.
-  //
-  // FIXME: This is wrong. For example:
-  //
-  //   template<typename T> using Vec = T __attribute__((ext_vector_type(4)));
-  //   Vec<int> vi;
-  //   vi.Vec<int>::~Vec<int>();
-  //
-  // ... should be accepted but we will not treat 'Vec' as a template name
-  // here. The right thing to do would be to check if the name is a valid
-  // vector component name, and look up a template name if not. And similarly
-  // for lookups into Objective-C class and object types, where the same
-  // problem can arise.
-  if (!ObjectType.isNull() && (ObjectType->isVectorType() ||
-                               ObjectType->isObjCObjectOrInterfaceType())) {
-    Found.clear();
-    return false;
-  }
+  // Determine where to perform name lookup
+  DeclContext *LookupCtx = nullptr;
+  bool IsDependent = false;
+  if (!ObjectType.isNull()) {
+    // This nested-name-specifier occurs in a member access expression, e.g.,
+    // x->B::f, and we are looking into the type of the object.
+    assert(SS.isEmpty() && "ObjectType and scope specifier cannot coexist");
+    LookupCtx = computeDeclContext(ObjectType);
+    IsDependent = !LookupCtx && ObjectType->isDependentType();
+    assert((IsDependent || !ObjectType->isIncompleteType() ||
+            !ObjectType->getAs<TagType>() ||
+            ObjectType->castAs<TagType>()->isBeingDefined()) &&
+           "Caller should have completed object type");
 
-  LookupParsedName(Found, S, &SS, ObjectType,
-                   /*AllowBuiltinCreation=*/false, EnteringContext);
+    // Template names cannot appear inside an Objective-C class or object type
+    // or a vector type.
+    //
+    // FIXME: This is wrong. For example:
+    //
+    //   template<typename T> using Vec = T __attribute__((ext_vector_type(4)));
+    //   Vec<int> vi;
+    //   vi.Vec<int>::~Vec<int>();
+    //
+    // ... should be accepted but we will not treat 'Vec' as a template name
+    // here. The right thing to do would be to check if the name is a valid
+    // vector component name, and look up a template name if not. And similarly
+    // for lookups into Objective-C class and object types, where the same
+    // problem can arise.
+    if (ObjectType->isObjCObjectOrInterfaceType() ||
+        ObjectType->isVectorType()) {
+      Found.clear();
+      return false;
+    }
+  } else if (SS.isNotEmpty()) {
+    // This nested-name-specifier occurs after another nested-name-specifier,
+    // so long into the context associated with the prior nested-name-specifier.
+    LookupCtx = computeDeclContext(SS, EnteringContext);
+    IsDependent = !LookupCtx && isDependentScopeSpecifier(SS);
 
-  // C++ [basic.lookup.qual.general]p3:
-  //   [...] Unless otherwise specified, a qualified name undergoes qualified
-  //   name lookup in its lookup context from the point where it appears unless
-  //   the lookup context either is dependent and is not the current
-  //   instantiation or is not a class or class template.
-  //
-  // The lookup context is dependent and either:
-  // - it is not the current instantiation, or
-  // - it is the current instantiation, it has at least one dependent base
-  //   class, and qualified lookup found nothing.
-  //
-  // If this is a member-qualified name that is the terminal name of a
-  // nested-name-specifier, we perform unqualified lookup and store the results
-  // so we can replicate the lookup during instantiation. The results of the
-  // unqualified loookup are *not* used to determine whether '<' is interpreted
-  // as the delimiter of a template-argument-list.
-  //
-  // For example:
-  //
-  //   template<typename T>
-  //   struct A {
-  //     int x;
-  //   };
-  //
-  //   template<typename T>
-  //   using B = A<T>;
-  //
-  //   template<typename T>
-  //   void f(A<T> a, A<int> b) {
-  //     a.B<T>::x; // error: missing 'template' before 'B'
-  //     b.B<int>::x; // ok, lookup context is not dependent
-  //   }
-  if (Found.wasNotFoundInCurrentInstantiation())
-    return false;
+    // The declaration context must be complete.
+    if (LookupCtx && RequireCompleteDeclContext(SS, LookupCtx))
+      return true;
+  }
 
   bool ObjectTypeSearchedInScope = false;
-
-  // C++ [basic.lookup.qual.general]p2:
-  //   A member-qualified name is the (unique) component name, if any, of
-  //   - an unqualified-id or
-  //   - a nested-name-specifier of the form type-name :: or namespace-name ::
-  //   in the id-expression of a class member access expression.
-  //
-  // C++ [basic.lookup.qual.general]p3:
-  //   [...] If nothing is found by qualified lookup for a member-qualified
-  //   name that is the terminal name of a nested-name-specifier and is not
-  //   dependent, it undergoes unqualified lookup.
-  //
-  // In 'x.A::B::y', 'A' will undergo unqualified lookup if qualified lookup
-  // in the type of 'x' finds nothing. If the lookup context is dependent,
-  // we perform the unqualified lookup in the template definition context
-  // and store the results so we can replicate the lookup during instantiation.
-  if (MayBeNNS && Found.empty() && !ObjectType.isNull()) {
-    if (S) {
+  bool AllowFunctionTemplatesInLookup = true;
+  if (LookupCtx) {
+    // Perform "qualified" name lookup into the declaration context we
+    // computed, which is either the type of the base of a member access
+    // expression or the declaration context associated with a prior
+    // nested-name-specifier.
+    LookupQualifiedName(Found, LookupCtx);
+
+    // FIXME: The C++ standard does not clearly specify what happens in the
+    // case where the object type is dependent, and implementations vary. In
+    // Clang, we treat a name after a . or -> as a template-name if lookup
+    // finds a non-dependent member or member of the current instantiation that
+    // is a type template, or finds no such members and lookup in the context
+    // of the postfix-expression finds a type template. In the latter case, the
+    // name is nonetheless dependent, and we may resolve it to a member of an
+    // unknown specialization when we come to instantiate the template.
+    IsDependent |= Found.wasNotFoundInCurrentInstantiation();
+  }
+
+  if (SS.isEmpty() && (ObjectType.isNull() || Found.empty())) {
+    // C++ [basic.lookup.classref]p1:
+    //   In a class member access expression (5.2.5), if the . or -> token is
+    //   immediately followed by an identifier followed by a <, the
+    //   identifier must be looked up to determine whether the < is the
+    //   beginning of a template argument list (14.2) or a less-than operator.
+    //   The identifier is first looked up in the class of the object
+    //   expression. If the identifier is not found, it is then looked up in
+    //   the context of the entire postfix-expression and shall name a class
+    //   template.
+    if (S)
       LookupName(Found, S);
-    } else if (!SS.getUnqualifiedLookups().empty()) {
-      Found.addAllDecls(SS.getUnqualifiedLookups());
-      Found.resolveKind();
+
+    if (!ObjectType.isNull()) {
+      //  FIXME: We should filter out all non-type templates here, particularly
+      //  variable templates and concepts. But the exclusion of alias templates
+      //  and template template parameters is a wording defect.
+      AllowFunctionTemplatesInLookup = false;
+      ObjectTypeSearchedInScope = true;
     }
-    ObjectTypeSearchedInScope = true;
+
+    IsDependent |= Found.wasNotFoundInCurrentInstantiation();
   }
 
   if (Found.isAmbiguous())
@@ -489,7 +494,7 @@
         getLangOpts().CPlusPlus20 && llvm::all_of(Found, [](NamedDecl *ND) {
           return isa<FunctionDecl>(ND->getUnderlyingDecl());
         });
-    if (AllFunctions || Found.empty()) {
+    if (AllFunctions || (Found.empty() && !IsDependent)) {
       // If lookup found any functions, or if this is a name that can only be
       // used for a function, then strongly assume this is a function
       // template-id.
@@ -501,15 +506,11 @@
     }
   }
 
-  if (Found.empty() && AllowTypoCorrection) {
+  if (Found.empty() && !IsDependent && AllowTypoCorrection) {
     // If we did not find any names, and this is not a disambiguation, attempt
     // to correct any typos.
     DeclarationName Name = Found.getLookupName();
     Found.clear();
-    DeclContext *LookupCtx =
-        SS.isSet()
-            ? computeDeclContext(SS, EnteringContext)
-            : (!ObjectType.isNull() ? computeDeclContext(ObjectType) : nullptr);
     // Simple filter callback that, for keywords, only accepts the C++ *_cast
     DefaultFilterCCC FilterCCC{};
     FilterCCC.WantTypeSpecifiers = false;
@@ -542,8 +543,13 @@
 
   NamedDecl *ExampleLookupResult =
       Found.empty() ? nullptr : Found.getRepresentativeDecl();
-  FilterAcceptableTemplateNames(Found);
+  FilterAcceptableTemplateNames(Found, AllowFunctionTemplatesInLookup);
   if (Found.empty()) {
+    if (IsDependent) {
+      Found.setNotFoundInCurrentInstantiation();
+      return false;
+    }
+
     // If a 'template' keyword was used, a lookup that finds only non-template
     // names is an error.
     if (ExampleLookupResult && RequiredTemplate) {
@@ -735,7 +741,7 @@
         /*IsArrow=*/!Context.getLangOpts().HLSL,
         /*OperatorLoc=*/SourceLocation(),
         /*QualifierLoc=*/NestedNameSpecifierLoc(), TemplateKWLoc,
-        /*UnqualifiedLookups=*/std::nullopt, NameInfo, TemplateArgs);
+        /*FirstQualifierFoundInScope=*/nullptr, NameInfo, TemplateArgs);
   }
   return BuildDependentDeclRefExpr(SS, TemplateKWLoc, NameInfo, TemplateArgs);
 }
@@ -5849,10 +5855,14 @@
   return BuildTemplateIdExpr(SS, TemplateKWLoc, R, /*ADL=*/false, TemplateArgs);
 }
 
-TemplateNameKind Sema::ActOnTemplateName(
-    Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,
-    const UnqualifiedId &Name, ParsedType ObjectType, bool EnteringContext,
-    TemplateTy &Result, bool AllowInjectedClassName, bool MayBeNNS) {
+TemplateNameKind Sema::ActOnTemplateName(Scope *S,
+                                         CXXScopeSpec &SS,
+                                         SourceLocation TemplateKWLoc,
+                                         const UnqualifiedId &Name,
+                                         ParsedType ObjectType,
+                                         bool EnteringContext,
+                                         TemplateTy &Result,
+                                         bool AllowInjectedClassName) {
   if (TemplateKWLoc.isValid() && S && !S->getTemplateParamParent())
     Diag(TemplateKWLoc,
          getLangOpts().CPlusPlus11 ?
@@ -5887,10 +5897,9 @@
   // "template" keyword is now permitted). We follow the C++0x
   // rules, even in C++03 mode with a warning, retroactively applying the DR.
   bool MemberOfUnknownSpecialization;
-  TemplateNameKind TNK =
-      isTemplateName(S, SS, TemplateKWLoc.isValid(), Name, ObjectType,
-                     EnteringContext, Result, MemberOfUnknownSpecialization,
-                     /*Disambiguation=*/false, MayBeNNS);
+  TemplateNameKind TNK = isTemplateName(S, SS, TemplateKWLoc.isValid(), Name,
+                                        ObjectType, EnteringContext, Result,
+                                        MemberOfUnknownSpecialization);
   if (TNK != TNK_Non_template) {
     // We resolved this to a (non-dependent) template name. Return it.
     auto *LookupRD = dyn_cast_or_null<CXXRecordDecl>(LookupCtx);
@@ -5929,8 +5938,7 @@
                                    ? RequiredTemplateKind(TemplateKWLoc)
                                    : TemplateNameIsRequired;
     if (!LookupTemplateName(R, S, SS, ObjectType.get(), EnteringContext, RTK,
-                            /*ATK=*/nullptr, /*AllowTypoCorrection=*/false,
-                            MayBeNNS) &&
+                            /*ATK=*/nullptr, /*AllowTypoCorrection=*/false) &&
         !R.isAmbiguous()) {
       if (LookupCtx)
         Diag(Name.getBeginLoc(), diag::err_no_member)
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaTemplateInstantiate.cpp b/clang/lib/Sema/SemaTemplateInstantiate.cpp
--- a/clang/lib/Sema/SemaTemplateInstantiate.cpp
+++ b/clang/lib/Sema/SemaTemplateInstantiate.cpp
@@ -1515,11 +1515,12 @@
                                    NestedNameSpecifierLoc QualifierLoc,
                                    QualType T);
 
-    TemplateName TransformTemplateName(CXXScopeSpec &SS, TemplateName Name,
-                                       SourceLocation NameLoc,
-                                       QualType ObjectType = QualType(),
-                                       bool AllowInjectedClassName = false,
-                                       bool MayBeNNS = false);
+    TemplateName
+    TransformTemplateName(CXXScopeSpec &SS, TemplateName Name,
+                          SourceLocation NameLoc,
+                          QualType ObjectType = QualType(),
+                          NamedDecl *FirstQualifierInScope = nullptr,
+                          bool AllowInjectedClassName = false);
 
     const CXXAssumeAttr *TransformCXXAssumeAttr(const CXXAssumeAttr *AA);
     const LoopHintAttr *TransformLoopHintAttr(const LoopHintAttr *LH);
@@ -1951,7 +1952,8 @@
 
 TemplateName TemplateInstantiator::TransformTemplateName(
     CXXScopeSpec &SS, TemplateName Name, SourceLocation NameLoc,
-    QualType ObjectType, bool AllowInjectedClassName, bool MayBeNNS) {
+    QualType ObjectType, NamedDecl *FirstQualifierInScope,
+    bool AllowInjectedClassName) {
   if (TemplateTemplateParmDecl *TTP
        = dyn_cast_or_null<TemplateTemplateParmDecl>(Name.getAsTemplateDecl())) {
     if (TTP->getDepth() < TemplateArgs.getNumLevels()) {
@@ -2023,7 +2025,8 @@
   }
 
   return inherited::TransformTemplateName(SS, Name, NameLoc, ObjectType,
-                                          AllowInjectedClassName, MayBeNNS);
+                                          FirstQualifierInScope,
+                                          AllowInjectedClassName);
 }
 
 ExprResult
diff -ruN --strip-trailing-cr a/clang/lib/Sema/TreeTransform.h b/clang/lib/Sema/TreeTransform.h
--- a/clang/lib/Sema/TreeTransform.h
+++ b/clang/lib/Sema/TreeTransform.h
@@ -541,9 +541,10 @@
   /// By default, transforms all of the types and declarations within the
   /// nested-name-specifier. Subclasses may override this function to provide
   /// alternate behavior.
-  NestedNameSpecifierLoc TransformNestedNameSpecifierLoc(
-      NestedNameSpecifierLoc NNS, QualType ObjectType = QualType(),
-      ArrayRef<DeclAccessPair> UnqualifiedLookups = std::nullopt);
+  NestedNameSpecifierLoc
+  TransformNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS,
+                                  QualType ObjectType = QualType(),
+                                  NamedDecl *FirstQualifierInScope = nullptr);
 
   /// Transform the given declaration name.
   ///
@@ -584,11 +585,12 @@
   /// By default, transforms the template name by transforming the declarations
   /// and nested-name-specifiers that occur within the template name.
   /// Subclasses may override this function to provide alternate behavior.
-  TemplateName TransformTemplateName(CXXScopeSpec &SS, TemplateName Name,
-                                     SourceLocation NameLoc,
-                                     QualType ObjectType = QualType(),
-                                     bool AllowInjectedClassName = false,
-                                     bool MayBeNNS = false);
+  TemplateName
+  TransformTemplateName(CXXScopeSpec &SS, TemplateName Name,
+                        SourceLocation NameLoc,
+                        QualType ObjectType = QualType(),
+                        NamedDecl *FirstQualifierInScope = nullptr,
+                        bool AllowInjectedClassName = false);
 
   /// Transform the given template argument.
   ///
@@ -1138,8 +1140,8 @@
     CXXScopeSpec SS;
     SS.Adopt(QualifierLoc);
     TemplateName InstName = getDerived().RebuildTemplateName(
-        SS, TemplateKWLoc, *Name, NameLoc, QualType(), AllowInjectedClassName,
-        /*MayBeNNS=*/false);
+        SS, TemplateKWLoc, *Name, NameLoc, QualType(), nullptr,
+        AllowInjectedClassName);
 
     if (InstName.isNull())
       return QualType();
@@ -1310,7 +1312,8 @@
                                    SourceLocation TemplateKWLoc,
                                    const IdentifierInfo &Name,
                                    SourceLocation NameLoc, QualType ObjectType,
-                                   bool AllowInjectedClassName, bool MayBeNNS);
+                                   NamedDecl *FirstQualifierInScope,
+                                   bool AllowInjectedClassName);
 
   /// Build a new template name given a nested name specifier and the
   /// overloaded operator name that is referred to as a template.
@@ -2846,14 +2849,15 @@
   ///
   /// By default, performs semantic analysis to build the new expression.
   /// Subclasses may override this routine to provide different behavior.
-  ExprResult
-  RebuildMemberExpr(Expr *Base, SourceLocation OpLoc, bool isArrow,
-                    NestedNameSpecifierLoc QualifierLoc,
-                    SourceLocation TemplateKWLoc,
-                    const DeclarationNameInfo &MemberNameInfo,
-                    ValueDecl *Member, NamedDecl *FoundDecl,
-                    const TemplateArgumentListInfo *ExplicitTemplateArgs,
-                    ArrayRef<DeclAccessPair> UnqualifiedLookups) {
+  ExprResult RebuildMemberExpr(Expr *Base, SourceLocation OpLoc,
+                               bool isArrow,
+                               NestedNameSpecifierLoc QualifierLoc,
+                               SourceLocation TemplateKWLoc,
+                               const DeclarationNameInfo &MemberNameInfo,
+                               ValueDecl *Member,
+                               NamedDecl *FoundDecl,
+                        const TemplateArgumentListInfo *ExplicitTemplateArgs,
+                               NamedDecl *FirstQualifierInScope) {
     ExprResult BaseResult = getSema().PerformMemberExprBaseConversion(Base,
                                                                       isArrow);
     if (!Member->getDeclName()) {
@@ -2890,7 +2894,6 @@
 
     CXXScopeSpec SS;
     SS.Adopt(QualifierLoc);
-    SS.setUnqualifiedLookups(UnqualifiedLookups);
 
     Base = BaseResult.get();
     if (Base->containsErrors())
@@ -2923,9 +2926,10 @@
     }
 
     return getSema().BuildMemberReferenceExpr(Base, BaseType, OpLoc, isArrow,
-                                              SS, TemplateKWLoc, R,
-                                              ExplicitTemplateArgs,
-                                              /*S=*/nullptr);
+                                              SS, TemplateKWLoc,
+                                              FirstQualifierInScope,
+                                              R, ExplicitTemplateArgs,
+                                              /*S*/nullptr);
   }
 
   /// Build a new binary operator expression.
@@ -2998,9 +3002,10 @@
     CXXScopeSpec SS;
     DeclarationNameInfo NameInfo(&Accessor, AccessorLoc);
     return getSema().BuildMemberReferenceExpr(
-        Base, Base->getType(), OpLoc, IsArrow, SS,
-        /*TemplateKWLoc=*/SourceLocation(), NameInfo,
-        /*TemplateArgs=*/nullptr, /*S=*/nullptr);
+        Base, Base->getType(), OpLoc, IsArrow, SS, SourceLocation(),
+        /*FirstQualifierInScope*/ nullptr, NameInfo,
+        /* TemplateArgs */ nullptr,
+        /*S*/ nullptr);
   }
 
   /// Build a new initializer list expression.
@@ -3568,37 +3573,46 @@
   ///
   /// By default, performs semantic analysis to build the new expression.
   /// Subclasses may override this routine to provide different behavior.
-  ExprResult RebuildCXXDependentScopeMemberExpr(
-      Expr *BaseE, QualType BaseType, bool IsArrow, SourceLocation OperatorLoc,
-      NestedNameSpecifierLoc QualifierLoc, SourceLocation TemplateKWLoc,
-      ArrayRef<DeclAccessPair> UnqualifiedLookups,
-      const DeclarationNameInfo &MemberNameInfo,
-      const TemplateArgumentListInfo *TemplateArgs) {
+  ExprResult RebuildCXXDependentScopeMemberExpr(Expr *BaseE,
+                                                QualType BaseType,
+                                                bool IsArrow,
+                                                SourceLocation OperatorLoc,
+                                          NestedNameSpecifierLoc QualifierLoc,
+                                                SourceLocation TemplateKWLoc,
+                                            NamedDecl *FirstQualifierInScope,
+                                   const DeclarationNameInfo &MemberNameInfo,
+                              const TemplateArgumentListInfo *TemplateArgs) {
     CXXScopeSpec SS;
     SS.Adopt(QualifierLoc);
-    SS.setUnqualifiedLookups(UnqualifiedLookups);
 
-    return SemaRef.BuildMemberReferenceExpr(
-        BaseE, BaseType, OperatorLoc, IsArrow, SS, TemplateKWLoc,
-        MemberNameInfo, TemplateArgs, /*S=*/nullptr);
+    return SemaRef.BuildMemberReferenceExpr(BaseE, BaseType,
+                                            OperatorLoc, IsArrow,
+                                            SS, TemplateKWLoc,
+                                            FirstQualifierInScope,
+                                            MemberNameInfo,
+                                            TemplateArgs, /*S*/nullptr);
   }
 
   /// Build a new member reference expression.
   ///
   /// By default, performs semantic analysis to build the new expression.
   /// Subclasses may override this routine to provide different behavior.
-  ExprResult RebuildUnresolvedMemberExpr(
-      Expr *BaseE, QualType BaseType, SourceLocation OperatorLoc, bool IsArrow,
-      NestedNameSpecifierLoc QualifierLoc, SourceLocation TemplateKWLoc,
-      ArrayRef<DeclAccessPair> UnqualifiedLookups, LookupResult &R,
-      const TemplateArgumentListInfo *TemplateArgs) {
+  ExprResult RebuildUnresolvedMemberExpr(Expr *BaseE, QualType BaseType,
+                                         SourceLocation OperatorLoc,
+                                         bool IsArrow,
+                                         NestedNameSpecifierLoc QualifierLoc,
+                                         SourceLocation TemplateKWLoc,
+                                         NamedDecl *FirstQualifierInScope,
+                                         LookupResult &R,
+                                const TemplateArgumentListInfo *TemplateArgs) {
     CXXScopeSpec SS;
     SS.Adopt(QualifierLoc);
-    SS.setUnqualifiedLookups(UnqualifiedLookups);
 
-    return SemaRef.BuildMemberReferenceExpr(BaseE, BaseType, OperatorLoc,
-                                            IsArrow, SS, TemplateKWLoc, R,
-                                            TemplateArgs, /*S=*/nullptr);
+    return SemaRef.BuildMemberReferenceExpr(BaseE, BaseType,
+                                            OperatorLoc, IsArrow,
+                                            SS, TemplateKWLoc,
+                                            FirstQualifierInScope,
+                                            R, TemplateArgs, /*S*/nullptr);
   }
 
   /// Build a new noexcept expression.
@@ -3817,8 +3831,10 @@
     DeclarationNameInfo NameInfo(Ivar->getDeclName(), IvarLoc);
     ExprResult Result = getSema().BuildMemberReferenceExpr(
         BaseArg, BaseArg->getType(),
-        /*FIXME:*/ IvarLoc, IsArrow, SS, /*TemplateKWLoc=*/SourceLocation(),
-        NameInfo, /*TemplateArgs=*/nullptr, /*S=*/nullptr);
+        /*FIXME:*/ IvarLoc, IsArrow, SS, SourceLocation(),
+        /*FirstQualifierInScope=*/nullptr, NameInfo,
+        /*TemplateArgs=*/nullptr,
+        /*S=*/nullptr);
     if (IsFreeIvar && Result.isUsable())
       cast<ObjCIvarRefExpr>(Result.get())->setIsFreeIvar(IsFreeIvar);
     return Result;
@@ -3833,12 +3849,14 @@
                                         SourceLocation PropertyLoc) {
     CXXScopeSpec SS;
     DeclarationNameInfo NameInfo(Property->getDeclName(), PropertyLoc);
-    return getSema().BuildMemberReferenceExpr(
-        BaseArg, BaseArg->getType(),
-        /*FIXME:*/ PropertyLoc,
-        /*IsArrow=*/false, SS, /*TemplateKWLoc=*/SourceLocation(), NameInfo,
-        /*TemplateArgs=*/nullptr,
-        /*S=*/nullptr);
+    return getSema().BuildMemberReferenceExpr(BaseArg, BaseArg->getType(),
+                                              /*FIXME:*/PropertyLoc,
+                                              /*IsArrow=*/false,
+                                              SS, SourceLocation(),
+                                              /*FirstQualifierInScope=*/nullptr,
+                                              NameInfo,
+                                              /*TemplateArgs=*/nullptr,
+                                              /*S=*/nullptr);
   }
 
   /// Build a new Objective-C property reference expression.
@@ -3865,11 +3883,13 @@
                                 SourceLocation OpLoc, bool IsArrow) {
     CXXScopeSpec SS;
     DeclarationNameInfo NameInfo(&getSema().Context.Idents.get("isa"), IsaLoc);
-    return getSema().BuildMemberReferenceExpr(
-        BaseArg, BaseArg->getType(), OpLoc, IsArrow, SS,
-        /*TemplateKWLoc=*/SourceLocation(), NameInfo,
-        /*TemplateArgs=*/nullptr,
-        /*S=*/nullptr);
+    return getSema().BuildMemberReferenceExpr(BaseArg, BaseArg->getType(),
+                                              OpLoc, IsArrow,
+                                              SS, SourceLocation(),
+                                              /*FirstQualifierInScope=*/nullptr,
+                                              NameInfo,
+                                              /*TemplateArgs=*/nullptr,
+                                              /*S=*/nullptr);
   }
 
   /// Build a new shuffle vector expression.
@@ -4034,14 +4054,18 @@
   }
 
 private:
-  TypeLoc TransformTypeInObjectScope(TypeLoc TL, QualType ObjectType,
+  TypeLoc TransformTypeInObjectScope(TypeLoc TL,
+                                     QualType ObjectType,
+                                     NamedDecl *FirstQualifierInScope,
                                      CXXScopeSpec &SS);
 
   TypeSourceInfo *TransformTypeInObjectScope(TypeSourceInfo *TSInfo,
                                              QualType ObjectType,
+                                             NamedDecl *FirstQualifierInScope,
                                              CXXScopeSpec &SS);
 
   TypeSourceInfo *TransformTSIInObjectScope(TypeLoc TL, QualType ObjectType,
+                                            NamedDecl *FirstQualifierInScope,
                                             CXXScopeSpec &SS);
 
   QualType TransformDependentNameType(TypeLocBuilder &TLB,
@@ -4360,7 +4384,7 @@
 template <typename Derived>
 NestedNameSpecifierLoc TreeTransform<Derived>::TransformNestedNameSpecifierLoc(
     NestedNameSpecifierLoc NNS, QualType ObjectType,
-    ArrayRef<DeclAccessPair> UnqualifiedLookups) {
+    NamedDecl *FirstQualifierInScope) {
   SmallVector<NestedNameSpecifierLoc, 4> Qualifiers;
 
   auto insertNNS = [&Qualifiers](NestedNameSpecifierLoc NNS) {
@@ -4371,8 +4395,6 @@
   insertNNS(NNS);
 
   CXXScopeSpec SS;
-  SS.setUnqualifiedLookups(UnqualifiedLookups);
-
   while (!Qualifiers.empty()) {
     NestedNameSpecifierLoc Q = Qualifiers.pop_back_val();
     NestedNameSpecifier *QNNS = Q.getNestedNameSpecifier();
@@ -4382,9 +4404,8 @@
       Sema::NestedNameSpecInfo IdInfo(QNNS->getAsIdentifier(),
                                       Q.getLocalBeginLoc(), Q.getLocalEndLoc(),
                                       ObjectType);
-      if (SemaRef.BuildCXXNestedNameSpecifier(/*Scope=*/nullptr, IdInfo,
-                                              /*EnteringContext=*/false, SS,
-                                              /*ErrorRecoveryLookup=*/false))
+      if (SemaRef.BuildCXXNestedNameSpecifier(/*Scope=*/nullptr, IdInfo, false,
+                                              SS, FirstQualifierInScope, false))
         return NestedNameSpecifierLoc();
       break;
     }
@@ -4422,7 +4443,8 @@
 
     case NestedNameSpecifier::TypeSpecWithTemplate:
     case NestedNameSpecifier::TypeSpec: {
-      TypeLoc TL = TransformTypeInObjectScope(Q.getTypeLoc(), ObjectType, SS);
+      TypeLoc TL = TransformTypeInObjectScope(Q.getTypeLoc(), ObjectType,
+                                              FirstQualifierInScope, SS);
 
       if (!TL)
         return NestedNameSpecifierLoc();
@@ -4455,7 +4477,7 @@
     }
 
     // The qualifier-in-scope and object type only apply to the leftmost entity.
-    SS.setUnqualifiedLookups(std::nullopt);
+    FirstQualifierInScope = nullptr;
     ObjectType = QualType();
   }
 
@@ -4538,10 +4560,14 @@
   llvm_unreachable("Unknown name kind.");
 }
 
-template <typename Derived>
-TemplateName TreeTransform<Derived>::TransformTemplateName(
-    CXXScopeSpec &SS, TemplateName Name, SourceLocation NameLoc,
-    QualType ObjectType, bool AllowInjectedClassName, bool MayBeNNS) {
+template<typename Derived>
+TemplateName
+TreeTransform<Derived>::TransformTemplateName(CXXScopeSpec &SS,
+                                              TemplateName Name,
+                                              SourceLocation NameLoc,
+                                              QualType ObjectType,
+                                              NamedDecl *FirstQualifierInScope,
+                                              bool AllowInjectedClassName) {
   if (QualifiedTemplateName *QTN = Name.getAsQualifiedTemplateName()) {
     TemplateDecl *Template = QTN->getUnderlyingTemplate().getAsTemplateDecl();
     assert(Template && "qualified template name must refer to a template");
@@ -4565,7 +4591,7 @@
     if (SS.getScopeRep()) {
       // These apply to the scope specifier, not the template.
       ObjectType = QualType();
-      SS.setUnqualifiedLookups(std::nullopt);
+      FirstQualifierInScope = nullptr;
     }
 
     if (!getDerived().AlwaysRebuild() &&
@@ -4577,9 +4603,13 @@
     SourceLocation TemplateKWLoc = NameLoc;
 
     if (DTN->isIdentifier()) {
-      return getDerived().RebuildTemplateName(
-          SS, TemplateKWLoc, *DTN->getIdentifier(), NameLoc, ObjectType,
-          AllowInjectedClassName, MayBeNNS);
+      return getDerived().RebuildTemplateName(SS,
+                                              TemplateKWLoc,
+                                              *DTN->getIdentifier(),
+                                              NameLoc,
+                                              ObjectType,
+                                              FirstQualifierInScope,
+                                              AllowInjectedClassName);
     }
 
     return getDerived().RebuildTemplateName(SS, TemplateKWLoc,
@@ -5123,31 +5153,39 @@
   return SemaRef.BuildQualifiedType(T, Loc, Quals);
 }
 
-template <typename Derived>
-TypeLoc TreeTransform<Derived>::TransformTypeInObjectScope(TypeLoc TL,
-                                                           QualType ObjectType,
-                                                           CXXScopeSpec &SS) {
+template<typename Derived>
+TypeLoc
+TreeTransform<Derived>::TransformTypeInObjectScope(TypeLoc TL,
+                                                   QualType ObjectType,
+                                                   NamedDecl *UnqualLookup,
+                                                   CXXScopeSpec &SS) {
   if (getDerived().AlreadyTransformed(TL.getType()))
     return TL;
 
-  TypeSourceInfo *TSI = TransformTSIInObjectScope(TL, ObjectType, SS);
+  TypeSourceInfo *TSI =
+      TransformTSIInObjectScope(TL, ObjectType, UnqualLookup, SS);
   if (TSI)
     return TSI->getTypeLoc();
   return TypeLoc();
 }
 
-template <typename Derived>
-TypeSourceInfo *TreeTransform<Derived>::TransformTypeInObjectScope(
-    TypeSourceInfo *TSInfo, QualType ObjectType, CXXScopeSpec &SS) {
+template<typename Derived>
+TypeSourceInfo *
+TreeTransform<Derived>::TransformTypeInObjectScope(TypeSourceInfo *TSInfo,
+                                                   QualType ObjectType,
+                                                   NamedDecl *UnqualLookup,
+                                                   CXXScopeSpec &SS) {
   if (getDerived().AlreadyTransformed(TSInfo->getType()))
     return TSInfo;
 
-  return TransformTSIInObjectScope(TSInfo->getTypeLoc(), ObjectType, SS);
+  return TransformTSIInObjectScope(TSInfo->getTypeLoc(), ObjectType,
+                                   UnqualLookup, SS);
 }
 
 template <typename Derived>
 TypeSourceInfo *TreeTransform<Derived>::TransformTSIInObjectScope(
-    TypeLoc TL, QualType ObjectType, CXXScopeSpec &SS) {
+    TypeLoc TL, QualType ObjectType, NamedDecl *UnqualLookup,
+    CXXScopeSpec &SS) {
   QualType T = TL.getType();
   assert(!getDerived().AlreadyTransformed(T));
 
@@ -5160,7 +5198,7 @@
 
     TemplateName Template = getDerived().TransformTemplateName(
         SS, SpecTL.getTypePtr()->getTemplateName(), SpecTL.getTemplateNameLoc(),
-        ObjectType, /*AllowInjectedClassName=*/true, /*MayBeNNS=*/true);
+        ObjectType, UnqualLookup, /*AllowInjectedClassName*/true);
     if (Template.isNull())
       return nullptr;
 
@@ -5170,11 +5208,13 @@
     DependentTemplateSpecializationTypeLoc SpecTL =
         TL.castAs<DependentTemplateSpecializationTypeLoc>();
 
-    TemplateName Template = getDerived().RebuildTemplateName(
-        SS, SpecTL.getTemplateKeywordLoc(),
-        *SpecTL.getTypePtr()->getIdentifier(), SpecTL.getTemplateNameLoc(),
-        ObjectType,
-        /*AllowInjectedClassName=*/true, /*MayBeNNS=*/true);
+    TemplateName Template
+      = getDerived().RebuildTemplateName(SS,
+                                         SpecTL.getTemplateKeywordLoc(),
+                                         *SpecTL.getTypePtr()->getIdentifier(),
+                                         SpecTL.getTemplateNameLoc(),
+                                         ObjectType, UnqualLookup,
+                                         /*AllowInjectedClassName*/true);
     if (Template.isNull())
       return nullptr;
 
@@ -12318,8 +12358,7 @@
   // first-qualifier-in-scope here, just in case we had a dependent
   // base (and therefore couldn't do the check) and a
   // nested-name-qualifier (and therefore could do the lookup).
-  ArrayRef<DeclAccessPair> UnqualifiedLookups;
-
+  NamedDecl *FirstQualifierInScope = nullptr;
   DeclarationNameInfo MemberNameInfo = E->getMemberNameInfo();
   if (MemberNameInfo.getName()) {
     MemberNameInfo = getDerived().TransformDeclarationNameInfo(MemberNameInfo);
@@ -12327,11 +12366,16 @@
       return ExprError();
   }
 
-  return getDerived().RebuildMemberExpr(
-      Base.get(), FakeOperatorLoc, E->isArrow(), QualifierLoc, TemplateKWLoc,
-      MemberNameInfo, Member, FoundDecl,
-      (E->hasExplicitTemplateArgs() ? &TransArgs : nullptr),
-      UnqualifiedLookups);
+  return getDerived().RebuildMemberExpr(Base.get(), FakeOperatorLoc,
+                                        E->isArrow(),
+                                        QualifierLoc,
+                                        TemplateKWLoc,
+                                        MemberNameInfo,
+                                        Member,
+                                        FoundDecl,
+                                        (E->hasExplicitTemplateArgs()
+                                           ? &TransArgs : nullptr),
+                                        FirstQualifierInScope);
 }
 
 template<typename Derived>
@@ -13458,8 +13502,9 @@
 
   PseudoDestructorTypeStorage Destroyed;
   if (E->getDestroyedTypeInfo()) {
-    TypeSourceInfo *DestroyedTypeInfo = getDerived().TransformTypeInObjectScope(
-        E->getDestroyedTypeInfo(), ObjectType, SS);
+    TypeSourceInfo *DestroyedTypeInfo
+      = getDerived().TransformTypeInObjectScope(E->getDestroyedTypeInfo(),
+                                                ObjectType, nullptr, SS);
     if (!DestroyedTypeInfo)
       return ExprError();
     Destroyed = DestroyedTypeInfo;
@@ -13485,7 +13530,7 @@
   if (E->getScopeTypeInfo()) {
     CXXScopeSpec EmptySS;
     ScopeTypeInfo = getDerived().TransformTypeInObjectScope(
-        E->getScopeTypeInfo(), ObjectType, EmptySS);
+                      E->getScopeTypeInfo(), ObjectType, nullptr, EmptySS);
     if (!ScopeTypeInfo)
       return ExprError();
   }
@@ -14746,17 +14791,19 @@
     ObjectType = BaseType->castAs<PointerType>()->getPointeeType();
   }
 
-  UnresolvedSet<4> UnqualifiedLookups;
-  for (auto D : E->unqualified_lookups()) {
-    if (NamedDecl *InstD = getDerived().TransformFirstQualifierInScope(
-            D.getDecl(), E->getQualifierLoc().getBeginLoc()))
-      UnqualifiedLookups.addDecl(InstD);
-  }
+  // Transform the first part of the nested-name-specifier that qualifies
+  // the member name.
+  NamedDecl *FirstQualifierInScope
+    = getDerived().TransformFirstQualifierInScope(
+                                            E->getFirstQualifierFoundInScope(),
+                                            E->getQualifierLoc().getBeginLoc());
 
   NestedNameSpecifierLoc QualifierLoc;
   if (E->getQualifier()) {
-    QualifierLoc = getDerived().TransformNestedNameSpecifierLoc(
-        E->getQualifierLoc(), ObjectType, UnqualifiedLookups.pairs());
+    QualifierLoc
+      = getDerived().TransformNestedNameSpecifierLoc(E->getQualifierLoc(),
+                                                     ObjectType,
+                                                     FirstQualifierInScope);
     if (!QualifierLoc)
       return ExprError();
   }
@@ -14775,16 +14822,23 @@
   if (!E->hasExplicitTemplateArgs()) {
     // This is a reference to a member without an explicitly-specified
     // template argument list. Optimize for this common case.
-    if (!getDerived().AlwaysRebuild() && Base.get() == OldBase &&
-        BaseType == E->getBaseType() && QualifierLoc == E->getQualifierLoc() &&
+    if (!getDerived().AlwaysRebuild() &&
+        Base.get() == OldBase &&
+        BaseType == E->getBaseType() &&
+        QualifierLoc == E->getQualifierLoc() &&
         NameInfo.getName() == E->getMember() &&
-        UnqualifiedLookups.pairs() == E->unqualified_lookups())
+        FirstQualifierInScope == E->getFirstQualifierFoundInScope())
       return E;
 
-    return getDerived().RebuildCXXDependentScopeMemberExpr(
-        Base.get(), BaseType, E->isArrow(), E->getOperatorLoc(), QualifierLoc,
-        TemplateKWLoc, UnqualifiedLookups.pairs(), NameInfo,
-        /*TemplateArgs*/ nullptr);
+    return getDerived().RebuildCXXDependentScopeMemberExpr(Base.get(),
+                                                       BaseType,
+                                                       E->isArrow(),
+                                                       E->getOperatorLoc(),
+                                                       QualifierLoc,
+                                                       TemplateKWLoc,
+                                                       FirstQualifierInScope,
+                                                       NameInfo,
+                                                       /*TemplateArgs*/nullptr);
   }
 
   TemplateArgumentListInfo TransArgs(E->getLAngleLoc(), E->getRAngleLoc());
@@ -14793,9 +14847,15 @@
                                               TransArgs))
     return ExprError();
 
-  return getDerived().RebuildCXXDependentScopeMemberExpr(
-      Base.get(), BaseType, E->isArrow(), E->getOperatorLoc(), QualifierLoc,
-      TemplateKWLoc, UnqualifiedLookups.pairs(), NameInfo, &TransArgs);
+  return getDerived().RebuildCXXDependentScopeMemberExpr(Base.get(),
+                                                     BaseType,
+                                                     E->isArrow(),
+                                                     E->getOperatorLoc(),
+                                                     QualifierLoc,
+                                                     TemplateKWLoc,
+                                                     FirstQualifierInScope,
+                                                     NameInfo,
+                                                     &TransArgs);
 }
 
 template <typename Derived>
@@ -14856,11 +14916,11 @@
   // first-qualifier-in-scope here, just in case we had a dependent
   // base (and therefore couldn't do the check) and a
   // nested-name-qualifier (and therefore could do the lookup).
-  ArrayRef<DeclAccessPair> UnqualifiedLookups;
+  NamedDecl *FirstQualifierInScope = nullptr;
 
   return getDerived().RebuildUnresolvedMemberExpr(
       Base.get(), BaseType, Old->getOperatorLoc(), Old->isArrow(), QualifierLoc,
-      TemplateKWLoc, UnqualifiedLookups, R,
+      TemplateKWLoc, FirstQualifierInScope, R,
       (Old->hasExplicitTemplateArgs() ? &TransArgs : nullptr));
 }
 
@@ -16217,18 +16277,22 @@
                                                   TemplateName(Template));
 }
 
-template <typename Derived>
-TemplateName TreeTransform<Derived>::RebuildTemplateName(
-    CXXScopeSpec &SS, SourceLocation TemplateKWLoc, const IdentifierInfo &Name,
-    SourceLocation NameLoc, QualType ObjectType, bool AllowInjectedClassName,
-    bool MayBeNNS) {
+template<typename Derived>
+TemplateName
+TreeTransform<Derived>::RebuildTemplateName(CXXScopeSpec &SS,
+                                            SourceLocation TemplateKWLoc,
+                                            const IdentifierInfo &Name,
+                                            SourceLocation NameLoc,
+                                            QualType ObjectType,
+                                            NamedDecl *FirstQualifierInScope,
+                                            bool AllowInjectedClassName) {
   UnqualifiedId TemplateName;
   TemplateName.setIdentifier(&Name, NameLoc);
   Sema::TemplateTy Template;
   getSema().ActOnTemplateName(/*Scope=*/nullptr, SS, TemplateKWLoc,
                               TemplateName, ParsedType::make(ObjectType),
                               /*EnteringContext=*/false, Template,
-                              AllowInjectedClassName, MayBeNNS);
+                              AllowInjectedClassName);
   return Template.get();
 }
 
@@ -16376,10 +16440,13 @@
   }
 
   SourceLocation TemplateKWLoc; // FIXME: retrieve it from caller.
-  return getSema().BuildMemberReferenceExpr(
-      Base, BaseType, OperatorLoc, isArrow, SS, TemplateKWLoc, NameInfo,
-      /*TemplateArgs=*/nullptr,
-      /*S=*/nullptr);
+  return getSema().BuildMemberReferenceExpr(Base, BaseType,
+                                            OperatorLoc, isArrow,
+                                            SS, TemplateKWLoc,
+                                            /*FIXME: FirstQualifier*/ nullptr,
+                                            NameInfo,
+                                            /*TemplateArgs*/ nullptr,
+                                            /*S*/nullptr);
 }
 
 template<typename Derived>
diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTReaderStmt.cpp b/clang/lib/Serialization/ASTReaderStmt.cpp
--- a/clang/lib/Serialization/ASTReaderStmt.cpp
+++ b/clang/lib/Serialization/ASTReaderStmt.cpp
@@ -1993,43 +1993,42 @@
     CXXDependentScopeMemberExpr *E) {
   VisitExpr(E);
 
-  CurrentUnpackingBits.emplace(Record.readInt());
-  bool HasQualifier = CurrentUnpackingBits->getNextBit();
-  bool HasTemplateInfo = CurrentUnpackingBits->getNextBit();
-  unsigned NumUnqualifiedLookups = Record.readInt();
   unsigned NumTemplateArgs = Record.readInt();
-  E->CXXDependentScopeMemberExprBits.HasQualifier = HasQualifier;
-  E->CXXDependentScopeMemberExprBits.NumUnqualifiedLookups =
-      NumUnqualifiedLookups;
-  E->CXXDependentScopeMemberExprBits.HasTemplateKWAndArgsInfo = HasTemplateInfo;
+  CurrentUnpackingBits.emplace(Record.readInt());
+  bool HasTemplateKWAndArgsInfo = CurrentUnpackingBits->getNextBit();
+  bool HasFirstQualifierFoundInScope = CurrentUnpackingBits->getNextBit();
+
+  assert((HasTemplateKWAndArgsInfo == E->hasTemplateKWAndArgsInfo()) &&
+         "Wrong HasTemplateKWAndArgsInfo!");
+  assert(
+      (HasFirstQualifierFoundInScope == E->hasFirstQualifierFoundInScope()) &&
+      "Wrong HasFirstQualifierFoundInScope!");
+
+  if (HasTemplateKWAndArgsInfo)
+    ReadTemplateKWAndArgsInfo(
+        *E->getTrailingObjects<ASTTemplateKWAndArgsInfo>(),
+        E->getTrailingObjects<TemplateArgumentLoc>(), NumTemplateArgs);
+
+  assert((NumTemplateArgs == E->getNumTemplateArgs()) &&
+         "Wrong NumTemplateArgs!");
 
-  E->BaseType = Record.readType();
   E->CXXDependentScopeMemberExprBits.IsArrow =
       CurrentUnpackingBits->getNextBit();
 
+  E->BaseType = Record.readType();
+  E->QualifierLoc = Record.readNestedNameSpecifierLoc();
+  // not ImplicitAccess
   if (CurrentUnpackingBits->getNextBit())
     E->Base = Record.readSubExpr();
   else
     E->Base = nullptr;
 
-  E->OperatorLoc = Record.readSourceLocation();
-  E->MemberNameInfo = Record.readDeclarationNameInfo();
+  E->CXXDependentScopeMemberExprBits.OperatorLoc = readSourceLocation();
 
-  if (HasQualifier)
-    new (E->getTrailingObjects<NestedNameSpecifierLoc>())
-        NestedNameSpecifierLoc(Record.readNestedNameSpecifierLoc());
-
-  for (unsigned I = 0; I != NumUnqualifiedLookups; ++I) {
-    auto *FoundD = Record.readDeclAs<NamedDecl>();
-    auto AS = (AccessSpecifier)Record.readInt();
-    E->getTrailingObjects<DeclAccessPair>()[I] =
-        DeclAccessPair::make(FoundD, AS);
-  }
+  if (HasFirstQualifierFoundInScope)
+    *E->getTrailingObjects<NamedDecl *>() = readDeclAs<NamedDecl>();
 
-  if (HasTemplateInfo)
-    ReadTemplateKWAndArgsInfo(
-        *E->getTrailingObjects<ASTTemplateKWAndArgsInfo>(),
-        E->getTrailingObjects<TemplateArgumentLoc>(), NumTemplateArgs);
+  E->MemberNameInfo = Record.readDeclarationNameInfo();
 }
 
 void
@@ -4076,16 +4075,16 @@
       break;
 
     case EXPR_CXX_DEPENDENT_SCOPE_MEMBER: {
+      unsigned NumTemplateArgs = Record[ASTStmtReader::NumExprFields];
       BitsUnpacker DependentScopeMemberBits(
-          Record[ASTStmtReader::NumExprFields]);
-      bool HasQualifier = DependentScopeMemberBits.getNextBit();
-      bool HasTemplateInfo = DependentScopeMemberBits.getNextBit();
-      unsigned NumUnqualifiedLookups = Record[ASTStmtReader::NumExprFields + 1];
-      unsigned NumTemplateArgs = Record[ASTStmtReader::NumExprFields + 2];
+          Record[ASTStmtReader::NumExprFields + 1]);
+      bool HasTemplateKWAndArgsInfo = DependentScopeMemberBits.getNextBit();
 
+      bool HasFirstQualifierFoundInScope =
+          DependentScopeMemberBits.getNextBit();
       S = CXXDependentScopeMemberExpr::CreateEmpty(
-          Context, HasQualifier, NumUnqualifiedLookups, HasTemplateInfo,
-          NumTemplateArgs);
+          Context, HasTemplateKWAndArgsInfo, NumTemplateArgs,
+          HasFirstQualifierFoundInScope);
       break;
     }
 
diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTWriterStmt.cpp b/clang/lib/Serialization/ASTWriterStmt.cpp
--- a/clang/lib/Serialization/ASTWriterStmt.cpp
+++ b/clang/lib/Serialization/ASTWriterStmt.cpp
@@ -1988,41 +1988,34 @@
     CXXDependentScopeMemberExpr *E) {
   VisitExpr(E);
 
-  bool HasQualifier = E->hasQualifier();
-  unsigned NumUnqualifiedLookups = E->getNumUnqualifiedLookups();
-  bool HasTemplateInfo = E->hasTemplateKWAndArgsInfo();
-  unsigned NumTemplateArgs = E->getNumTemplateArgs();
-
-  // Write these first for easy access when deserializing, as they affect the
-  // size of the CXXDependentScopeMemberExpr.
+  // Don't emit anything here (or if you do you will have to update
+  // the corresponding deserialization function).
+  Record.push_back(E->getNumTemplateArgs());
   CurrentPackingBits.updateBits();
-  CurrentPackingBits.addBit(HasQualifier);
-  CurrentPackingBits.addBit(HasTemplateInfo);
-  Record.push_back(NumUnqualifiedLookups);
-  Record.push_back(NumTemplateArgs);
+  CurrentPackingBits.addBit(E->hasTemplateKWAndArgsInfo());
+  CurrentPackingBits.addBit(E->hasFirstQualifierFoundInScope());
+
+  if (E->hasTemplateKWAndArgsInfo()) {
+    const ASTTemplateKWAndArgsInfo &ArgInfo =
+        *E->getTrailingObjects<ASTTemplateKWAndArgsInfo>();
+    AddTemplateKWAndArgsInfo(ArgInfo,
+                             E->getTrailingObjects<TemplateArgumentLoc>());
+  }
 
-  Record.AddTypeRef(E->getBaseType());
   CurrentPackingBits.addBit(E->isArrow());
+
+  Record.AddTypeRef(E->getBaseType());
+  Record.AddNestedNameSpecifierLoc(E->getQualifierLoc());
   CurrentPackingBits.addBit(!E->isImplicitAccess());
   if (!E->isImplicitAccess())
     Record.AddStmt(E->getBase());
 
   Record.AddSourceLocation(E->getOperatorLoc());
 
-  Record.AddDeclarationNameInfo(E->MemberNameInfo);
-
-  if (HasQualifier)
-    Record.AddNestedNameSpecifierLoc(E->getQualifierLoc());
-
-  for (DeclAccessPair D : E->unqualified_lookups()) {
-    Record.AddDeclRef(D.getDecl());
-    Record.push_back(D.getAccess());
-  }
-
-  if (HasTemplateInfo)
-    AddTemplateKWAndArgsInfo(*E->getTrailingObjects<ASTTemplateKWAndArgsInfo>(),
-                             E->getTrailingObjects<TemplateArgumentLoc>());
+  if (E->hasFirstQualifierFoundInScope())
+    Record.AddDeclRef(E->getFirstQualifierFoundInScope());
 
+  Record.AddDeclarationNameInfo(E->MemberNameInfo);
   Code = serialization::EXPR_CXX_DEPENDENT_SCOPE_MEMBER;
 }
 
diff -ruN --strip-trailing-cr a/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1-cxx11.cpp b/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1-cxx11.cpp
--- a/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1-cxx11.cpp
+++ b/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1-cxx11.cpp
@@ -55,19 +55,15 @@
 
   template<typename T> T *end(T*);
 
-  struct X { };
-  struct Y {
-    int end;
-  };
+  class X { };
   template <typename T>
   void Foo2() {
     T it1;
-    if (it1->end < it1->end) { }
+    if (it1->end < it1->end) {
+    }
 
     X *x;
-    if (x->end < 7) { } // expected-error{{no member named 'end' in 'PR11856::X'}}
-
-    Y *y;
-    if (y->end < 7) { }
+    if (x->end < 7) {  // expected-error{{no member named 'end' in 'PR11856::X'}}
+    }
   }
 }
diff -ruN --strip-trailing-cr a/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1.cpp b/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1.cpp
--- a/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1.cpp
+++ b/clang/test/CXX/basic/basic.lookup/basic.lookup.classref/p1.cpp
@@ -86,19 +86,15 @@
 
   template<typename T> T *end(T*);
 
-  struct X { };
-  struct Y {
-    int end;
-  };
+  class X { };
   template <typename T>
   void Foo2() {
     T it1;
-    if (it1->end < it1->end) { }
+    if (it1->end < it1->end) {
+    }
 
     X *x;
-    if (x->end < 7) { } // expected-error{{no member named 'end' in 'PR11856::X'}}
-
-    Y *y;
-    if (y->end < 7) { }
+    if (x->end < 7) {  // expected-error{{no member named 'end' in 'PR11856::X'}}
+    }
   }
 }
diff -ruN --strip-trailing-cr a/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3-example3.cpp b/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3-example3.cpp
--- a/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3-example3.cpp
+++ b/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3-example3.cpp
@@ -1,27 +0,0 @@
-// RUN: %clang_cc1 -std=c++23 %s -verify
-
-int f();
-
-struct A {
-  int B, C; // expected-note {{declared as a non-template here}}
-  template<int> using D = void;
-  using T = void;
-  void f();
-};
-
-using B = A;
-template<int> using C = A;
-template<int> using D = A;
-template<int> using X = A;
-
-template<class T>
-void g(T *p) {
-  p->X<0>::f(); // expected-error {{no member named 'X' in 'A'}}
-  p->template X<0>::f();
-  p->B::f();
-  p->template C<0>::f(); // expected-error {{'C' following the 'template' keyword does not refer to a template}}
-  p->template D<0>::f(); // expected-error {{type 'template D<0>' (aka 'void') cannot be used prior to '::' because it has no members}}
-  p->T::f(); // expected-error {{'A::T' (aka 'void') is not a class, namespace, or enumeration}}
-}
-
-template void g(A*); // expected-note {{in instantiation of}}
diff -ruN --strip-trailing-cr a/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3.cpp b/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3.cpp
--- a/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3.cpp
+++ b/clang/test/CXX/basic/basic.lookup/basic.lookup.qual/basic.lookup.qual.general/p3.cpp
@@ -1,98 +0,0 @@
-// RUN: %clang_cc1 -std=c++23 -Wno-unused %s -verify
-
-namespace Unambiguous {
-  struct A {
-    int x;
-
-    template<typename T>
-    using C = A;
-  };
-
-  using B = A;
-
-  template<typename T>
-  using D = A;
-
-  using E = void;
-
-  struct F : A {
-    void non_template() {
-      this->x;
-      this->A::x;
-      this->B::x;
-      this->C<int>::x;
-      this->D<int>::x;
-      this->E::x; // expected-error {{'Unambiguous::E' (aka 'void') is not a class, namespace, or enumeration}}
-    }
-  };
-
-  template<typename T>
-  void not_instantiated(T t) {
-    t.x;
-    t.A::x;
-    t.B::x;
-    t.C<int>::x; // expected-warning {{use 'template' keyword to treat 'C' as a dependent template name}}
-    t.template C<int>::x;
-    t.D<int>::x; // expected-warning {{use 'template' keyword to treat 'D' as a dependent template name}}
-    t.template D<int>::x;
-    t.E::x;
-  }
-
-  template<typename T>
-  void instantiated_valid(T t) {
-    t.x;
-    t.A::x;
-    t.B::x;
-    t.template C<int>::x;
-    t.template D<int>::x;
-    t.E::x;
-  }
-
-  template<typename T>
-  void instantiated_invalid(T t) {
-    t.x;
-    t.A::x;
-    t.B::x; // expected-error {{'Unambiguous::Invalid::B' (aka 'void') is not a class, namespace, or enumeration}}
-    t.template C<int>::x;
-    t.template D<int>::x; // expected-error {{'D' following the 'template' keyword does not refer to a template}}
-    t.E::x; // expected-error {{'Unambiguous::E' (aka 'void') is not a class, namespace, or enumeration}}
-  }
-
-  struct Valid : A {
-    using E = A;
-  };
-
-  template void instantiated_valid(Valid);
-
-  struct Invalid : A {
-    using B = void;
-    using D = A; // expected-note {{declared as a non-template here}}
-  };
-
-  template void instantiated_invalid(Invalid); // expected-note {{in instantiation of}}
-} // namespace Unambiguous
-
-namespace Ambiguous {
-  inline namespace N {
-    struct A { }; // expected-note {{candidate found by name lookup is 'Ambiguous::N::A'}}
-  }
-
-  struct A { }; // expected-note {{candidate found by name lookup is 'Ambiguous::A'}}
-
-  template<typename T>
-  void f(T t) {
-    t.A::x; // expected-error {{reference to 'A' is ambiguous}}
-  }
-
-  struct B {
-    using A = B;
-
-    int x;
-  };
-
-  struct C { };
-
-  template void f(B);
-  template void f(C); // expected-note {{in instantiation of}}
-
-} // namespace Ambiguous
diff -ruN --strip-trailing-cr a/clang/test/CXX/class.derived/class.member.lookup/p8.cpp b/clang/test/CXX/class.derived/class.member.lookup/p8.cpp
--- a/clang/test/CXX/class.derived/class.member.lookup/p8.cpp
+++ b/clang/test/CXX/class.derived/class.member.lookup/p8.cpp
@@ -47,8 +47,8 @@
 void DerivedT<T>::Inner() {
   Derived1T<T>::Foo();
   Derived2T<T>::Member = 42;
-  this->Derived1T<T>::Foo(); // expected-warning{{use 'template' keyword to treat 'Derived1T' as a dependent template name}}
-  this->Derived2T<T>::Member = 42; // expected-warning{{use 'template' keyword to treat 'Derived2T' as a dependent template name}}
+  this->Derived1T<T>::Foo();
+  this->Derived2T<T>::Member = 42;
   this->Foo(); // expected-error{{non-static member 'Foo' found in multiple base-class subobjects of type 'BaseT<int>'}}
 }
 
diff -ruN --strip-trailing-cr a/clang/test/CXX/drs/cwg1xx.cpp b/clang/test/CXX/drs/cwg1xx.cpp
--- a/clang/test/CXX/drs/cwg1xx.cpp
+++ b/clang/test/CXX/drs/cwg1xx.cpp
@@ -615,8 +615,10 @@
     //   cxx98-note@#cwg141-S {{lookup from the current scope refers here}}
     // expected-error@#cwg141-a {{no member named 'n' in 'cwg141::A::S<int>'; did you mean '::cwg141::S<int>::n'?}}
     //   expected-note@#cwg141-S {{'::cwg141::S<int>::n' declared here}}
+    // FIXME: we issue a useful diagnostic first, then some bogus ones.
     b.f<int>();
     // expected-error@-1 {{no member named 'f' in 'cwg141::B'}}
+    // expected-error@-2 +{{}}
     (void)b.S<int>::n;
   }
   template<typename T> struct C {
@@ -626,12 +628,10 @@
       // expected-error@-1 {{use 'template' keyword to treat 'f' as a dependent template name}}
     }
     void h() {
-      (void)t.S<int>::n;
-      // expected-error@-1 {{use 'template' keyword to treat 'S' as a dependent template name}}
+      (void)t.S<int>::n; // ok
     }
     void i() {
-      (void)t.S<int>();
-      // expected-error@-1 {{use 'template' keyword to treat 'S' as a dependent template name}}
+      (void)t.S<int>(); // ok!
     }
   };
   void h() { C<B>().h(); } // ok
diff -ruN --strip-trailing-cr a/clang/test/CXX/temp/temp.names/p3-23.cpp b/clang/test/CXX/temp/temp.names/p3-23.cpp
--- a/clang/test/CXX/temp/temp.names/p3-23.cpp
+++ b/clang/test/CXX/temp/temp.names/p3-23.cpp
@@ -1,237 +0,0 @@
-// RUN: %clang_cc1 -std=c++23 -Wno-unused %s -verify
-
-namespace FoundNothing {
-  template<typename T>
-  void f0(T &t) {
-    t.x<0;
-    t.x<0>; // expected-error {{expected expression}}
-    t.x<0>1;
-  }
-
-  template<typename T>
-  struct A {
-    void f1() {
-      this->x<0; // expected-error {{no member named 'x' in 'A<T>'}}
-      this->x<0>; // expected-error {{no member named 'x' in 'A<T>'}}
-                  // expected-error@-1 {{expected expression}}
-      this->x<0>1; // expected-error {{no member named 'x' in 'A<T>'}}
-    }
-  };
-} // namespace FoundNothing
-
-namespace FoundSingleNonTemplate {
-  void f0();
-
-  struct A0;
-
-  template<typename T>
-  void g0(T &t) {
-    t.f0<0;
-    t.f0<0>; // expected-error {{expected expression}}
-    t.f0<0>1;
-
-    t.A0<0;
-    t.A0<0>; // expected-error {{expected expression}}
-    t.A0<0>1;
-  }
-
-  template<typename T>
-  struct B {
-    void f1();
-
-    struct A1; // expected-note 3{{member 'A1' declared here}}
-
-    void g1() {
-      this->f0<0; // expected-error {{no member named 'f0' in 'B<T>'}}
-      this->f0<0>; // expected-error {{no member named 'f0' in 'B<T>'}}
-                   // expected-error@-1 {{expected expression}}
-      this->f0<0>1; // expected-error {{no member named 'f0' in 'B<T>'}}
-
-      this->A0<0; // expected-error {{no member named 'A0' in 'B<T>'}}
-      this->A0<0>; // expected-error {{no member named 'A0' in 'B<T>'}}
-                   // expected-error@-1 {{expected expression}}
-      this->A0<0>1; // expected-error {{no member named 'A0' in 'B<T>'}}
-
-      this->f1<0; // expected-error {{reference to non-static member function must be called}}
-      this->f1<0>; // expected-error {{reference to non-static member function must be called}}
-                   // expected-error@-1 {{expected expression}}
-      this->f1<0>1; // expected-error {{reference to non-static member function must be called}}
-
-      this->A1<0; // expected-error {{cannot refer to type member 'A1' in 'B<T>' with '->'}}
-      this->A1<0>; // expected-error {{cannot refer to type member 'A1' in 'B<T>' with '->'}}
-                   // expected-error@-1 {{expected expression}}
-      this->A1<0>1; // expected-error {{cannot refer to type member 'A1' in 'B<T>' with '->'}}
-    }
-  };
-} // namespace FoundSingleNonTemplate
-
-namespace FoundSingleTemplate {
-  template<int I>
-  void f0();
-
-  template<int I>
-  struct A0;
-
-  template<typename T>
-  void g0(T &t) {
-    t.f0<0;
-    t.f0<0>; // expected-error {{expected expression}}
-    t.f0<0>1;
-
-    t.A0<0;
-    t.A0<0>; // expected-error {{expected expression}}
-    t.A0<0>1;
-  }
-
-  template<typename T>
-  struct B {
-    template<int I>
-    void f1(); // expected-note 2{{possible target for call}}
-
-    template<int I>
-    struct A1; // expected-note 2{{member 'A1' declared here}}
-
-    void g1() {
-      this->f0<0; // expected-error {{no member named 'f0' in 'B<T>'}}
-      this->f0<0>; // expected-error {{no member named 'f0' in 'B<T>'}}
-      this->f0<0>1; // expected-error {{no member named 'f0' in 'B<T>'}}
-                    // expected-error@-1 {{expected ';' after expression}}
-
-      this->A0<0; // expected-error {{no member named 'A0' in 'B<T>'}}
-      this->A0<0>; // expected-error {{no member named 'A0' in 'B<T>'}}
-      this->A0<0>1; // expected-error {{no member named 'A0' in 'B<T>'}}
-                    // expected-error@-1 {{expected ';' after expression}}
-
-
-      this->f1<0; // expected-error {{expected '>'}}
-                  // expected-note@-1 {{to match this '<'}}
-      this->f1<0>; // expected-error {{reference to non-static member function must be called}}
-      this->f1<0>1; // expected-error {{reference to non-static member function must be called}}
-                    // expected-error@-1 {{expected ';' after expression}}
-
-      this->A1<0; // expected-error {{expected '>'}}
-                  // expected-note@-1 {{to match this '<'}}
-      this->A1<0>; // expected-error {{cannot refer to member 'A1' in 'B<T>' with '->'}}
-      this->A1<0>1; // expected-error {{cannot refer to member 'A1' in 'B<T>' with '->'}}
-                    // expected-error@-1 {{expected ';' after expression}}
-    }
-  };
-} // namespace FoundSingleTemplate
-
-namespace FoundAmbiguousNonTemplate {
-  inline namespace N {
-    int f0;
-
-    struct A0;
-  } // namespace N
-
-  void f0();
-
-  struct A0;
-
-  template<typename T>
-  void g0(T &t) {
-    t.f0<0;
-    t.f0<0>; // expected-error {{expected expression}}
-    t.f0<0>1;
-
-    t.A0<0;
-    t.A0<0>; // expected-error {{expected expression}}
-    t.A0<0>1;
-  }
-
-  template<typename T>
-  struct B {
-    void f1();
-
-    struct A1; // expected-note 3{{member 'A1' declared here}}
-
-    void g1() {
-      this->f0<0; // expected-error {{no member named 'f0' in 'B<T>'}}
-      this->f0<0>; // expected-error {{no member named 'f0' in 'B<T>'}}
-                   // expected-error@-1 {{expected expression}}
-      this->f0<0>1; // expected-error {{no member named 'f0' in 'B<T>'}}
-
-      this->A0<0; // expected-error {{no member named 'A0' in 'B<T>'}}
-      this->A0<0>; // expected-error {{no member named 'A0' in 'B<T>'}}
-                   // expected-error@-1 {{expected expression}}
-      this->A0<0>1; // expected-error {{no member named 'A0' in 'B<T>'}}
-
-      this->f1<0; // expected-error {{reference to non-static member function must be called}}
-      this->f1<0>; // expected-error {{reference to non-static member function must be called}}
-                   // expected-error@-1 {{expected expression}}
-      this->f1<0>1; // expected-error {{reference to non-static member function must be called}}
-
-      this->A1<0; // expected-error {{cannot refer to type member 'A1' in 'B<T>' with '->'}}
-      this->A1<0>; // expected-error {{cannot refer to type member 'A1' in 'B<T>' with '->'}}
-                   // expected-error@-1 {{expected expression}}
-      this->A1<0>1; // expected-error {{cannot refer to type member 'A1' in 'B<T>' with '->'}}
-    }
-  };
-} // namespace FoundAmbiguousNonTemplates
-
-namespace FoundAmbiguousTemplate {
-  inline namespace N {
-    template<int I>
-    int f0; // expected-note 3{{candidate found by name lookup is 'FoundAmbiguousTemplate::N::f0'}}
-
-    template<int I>
-    struct A0; // expected-note 3{{candidate found by name lookup is 'FoundAmbiguousTemplate::N::A0'}}
-  } // namespace N
-
-  template<int I>
-  void f0(); // expected-note 3{{candidate found by name lookup is 'FoundAmbiguousTemplate::f0'}}
-
-  template<int I>
-  struct A0; // expected-note 3{{candidate found by name lookup is 'FoundAmbiguousTemplate::A0'}}
-
-  template<typename T>
-  void g0(T &t) {
-    t.f0<0;
-    t.f0<0>; // expected-error {{expected expression}}
-    t.f0<0>1;
-
-    t.A0<0;
-    t.A0<0>; // expected-error {{expected expression}}
-    t.A0<0>1;
-  }
-
-  template<typename T>
-  struct B {
-    template<int I>
-    void f1(); // expected-note 2{{possible target for call}}
-
-    template<int I>
-    struct A1; // expected-note 2{{member 'A1' declared here}}
-
-    void g1() {
-      this->f0<0; // expected-error {{no member named 'f0' in 'B<T>'}}
-                  // expected-error@-1 {{reference to 'f0' is ambiguous}}
-      this->f0<0>; // expected-error {{no member named 'f0' in 'B<T>'}}
-                   // expected-error@-1 {{reference to 'f0' is ambiguous}}
-      this->f0<0>1; // expected-error {{no member named 'f0' in 'B<T>'}}
-                    // expected-error@-1 {{expected ';' after expression}}
-                    // expected-error@-2 {{reference to 'f0' is ambiguous}}
-
-      this->A0<0; // expected-error {{no member named 'A0' in 'B<T>'}}
-                  // expected-error@-1 {{reference to 'A0' is ambiguous}}
-      this->A0<0>; // expected-error {{no member named 'A0' in 'B<T>'}}
-                   // expected-error@-1 {{reference to 'A0' is ambiguous}}
-      this->A0<0>1; // expected-error {{no member named 'A0' in 'B<T>'}}
-                    // expected-error@-1 {{expected ';' after expression}}
-                    // expected-error@-2 {{reference to 'A0' is ambiguous}}
-
-      this->f1<0; // expected-error {{expected '>'}}
-                  // expected-note@-1 {{to match this '<'}}
-      this->f1<0>; // expected-error {{reference to non-static member function must be called}}
-      this->f1<0>1; // expected-error {{reference to non-static member function must be called}}
-                    // expected-error@-1 {{expected ';' after expression}}
-
-      this->A1<0; // expected-error {{expected '>'}}
-                  // expected-note@-1 {{to match this '<'}}
-      this->A1<0>; // expected-error {{cannot refer to member 'A1' in 'B<T>' with '->'}}
-      this->A1<0>1; // expected-error {{cannot refer to member 'A1' in 'B<T>' with '->'}}
-                    // expected-error@-1 {{expected ';' after expression}}
-    }
-  };
-} // namespace FoundAmbiguousTemplate
diff -ruN --strip-trailing-cr a/clang/test/CXX/temp/temp.res/p3.cpp b/clang/test/CXX/temp/temp.res/p3.cpp
--- a/clang/test/CXX/temp/temp.res/p3.cpp
+++ b/clang/test/CXX/temp/temp.res/p3.cpp
@@ -30,6 +30,6 @@
 template<typename T> template<typename U> struct A<T>::B {
   friend A<T>::C<T> f6(); // ok, same as 'friend T f6();'
 
-  friend A<U>::C<T> f7(); // expected-warning {{use 'template' keyword to treat 'C' as a dependent template name}} expected-warning {{missing 'typename'}}
+  friend A<U>::C<T> f7(); // expected-error {{use 'template' keyword to treat 'C' as a dependent template name}} expected-warning {{missing 'typename'}}
   friend A<U>::template C<T> f8(); // expected-warning {{missing 'typename'}}
 };
diff -ruN --strip-trailing-cr a/clang/test/FixIt/fixit.cpp b/clang/test/FixIt/fixit.cpp
--- a/clang/test/FixIt/fixit.cpp
+++ b/clang/test/FixIt/fixit.cpp
@@ -158,12 +158,12 @@
  
 template<class T>
 class F2  {
-  typename F1<T>:: /*template*/  Iterator<0> Mypos; // expected-warning {{use 'template' keyword to treat 'Iterator' as a dependent template name}}
+  typename F1<T>:: /*template*/  Iterator<0> Mypos; // expected-error {{use 'template' keyword to treat 'Iterator' as a dependent template name}}
 };
 
 template <class T>
 void f(){
-  typename F1<T>:: /*template*/ Iterator<0> Mypos; // expected-warning {{use 'template' keyword to treat 'Iterator' as a dependent template name}}
+  typename F1<T>:: /*template*/ Iterator<0> Mypos; // expected-error {{use 'template' keyword to treat 'Iterator' as a dependent template name}}
 }
 
 // Tests for &/* fixits
diff -ruN --strip-trailing-cr a/clang/test/Misc/warning-flags.c b/clang/test/Misc/warning-flags.c
--- a/clang/test/Misc/warning-flags.c
+++ b/clang/test/Misc/warning-flags.c
@@ -21,7 +21,6 @@
 CHECK: Warnings without flags (65):
 
 CHECK-NEXT:   ext_expected_semi_decl_list
-CHECK-NEXT:   ext_missing_dependent_template_keyword
 CHECK-NEXT:   ext_missing_whitespace_after_macro_name
 CHECK-NEXT:   ext_new_paren_array_nonconst
 CHECK-NEXT:   ext_plain_complex
@@ -62,6 +61,7 @@
 CHECK-NEXT:   warn_maynot_respond
 CHECK-NEXT:   warn_method_param_redefinition
 CHECK-NEXT:   warn_missing_case_for_condition
+CHECK-NEXT:   warn_missing_dependent_template_keyword
 CHECK-NEXT:   warn_missing_whitespace_after_macro_name
 CHECK-NEXT:   warn_mt_message
 CHECK-NEXT:   warn_no_constructor_for_refconst
diff -ruN --strip-trailing-cr a/clang/test/Parser/cxx2a-concepts-requires-expr.cpp b/clang/test/Parser/cxx2a-concepts-requires-expr.cpp
--- a/clang/test/Parser/cxx2a-concepts-requires-expr.cpp
+++ b/clang/test/Parser/cxx2a-concepts-requires-expr.cpp
@@ -78,7 +78,7 @@
 
 template<typename T>
 bool r23 = requires { typename identity<T>::temp<T>; };
-// expected-warning@-1 {{use 'template' keyword to treat 'temp' as a dependent template name}}
+// expected-error@-1 {{use 'template' keyword to treat 'temp' as a dependent template name}}
 
 template<typename T>
 bool r24 = requires {
diff -ruN --strip-trailing-cr a/clang/test/Sema/attr-format-missing.c b/clang/test/Sema/attr-format-missing.c
--- a/clang/test/Sema/attr-format-missing.c
+++ b/clang/test/Sema/attr-format-missing.c
@@ -1,403 +0,0 @@
-// RUN: %clang_cc1 -fsyntax-only -verify=expected,c_diagnostics -Wmissing-format-attribute %s
-// RUN: %clang_cc1 -fsyntax-only -Wmissing-format-attribute -fdiagnostics-parseable-fixits %s 2>&1 | FileCheck %s --check-prefixes=CHECK,C-CHECK
-// RUN: %clang_cc1 -fsyntax-only -x c++ -verify=expected,cpp_diagnostics -Wmissing-format-attribute %s
-// RUN: %clang_cc1 -fsyntax-only -x c++ -verify=expected,cpp_diagnostics -std=c++2b -Wmissing-format-attribute %s
-// RUN: %clang_cc1 -fsyntax-only -x c++ -verify=expected,cpp_diagnostics -std=c++23 -Wmissing-format-attribute %s
-// RUN: not %clang_cc1 -fsyntax-only -x c++ -Wmissing-format-attribute -fdiagnostics-parseable-fixits -triple x86_64-linux %s 2>&1 | FileCheck %s --check-prefixes=CHECK,CHECK-LIN64
-// RUN: not %clang_cc1 -fsyntax-only -x c++ -Wmissing-format-attribute -fdiagnostics-parseable-fixits -triple x86_64-windows %s 2>&1 | FileCheck %s --check-prefixes=CHECK
-// RUN: not %clang_cc1 -fsyntax-only -x c++ -Wmissing-format-attribute -fdiagnostics-parseable-fixits -triple i386-windows %s 2>&1 | FileCheck %s --check-prefixes=CHECK
-// RUN: not %clang_cc1 -fsyntax-only -x c++ -Wmissing-format-attribute -fdiagnostics-parseable-fixits -triple i386-windows %s 2>&1 | FileCheck %s --check-prefixes=CHECK
-
-#ifndef __cplusplus
-typedef unsigned short char16_t;
-typedef unsigned int char32_t;
-typedef __WCHAR_TYPE__ wchar_t;
-#endif
-
-typedef __SIZE_TYPE__ size_t;
-typedef __builtin_va_list va_list;
-
-__attribute__((__format__(__printf__, 1, 2)))
-int printf(const char *, ...); // #printf
-
-__attribute__((__format__(__scanf__, 1, 2)))
-int scanf(const char *, ...); // #scanf
-
-__attribute__((__format__(__printf__, 1, 0)))
-int vprintf(const char *, va_list); // #vprintf
-
-__attribute__((__format__(__scanf__, 1, 0)))
-int vscanf(const char *, va_list); // #vscanf
-
-__attribute__((__format__(__printf__, 2, 0)))
-int vsprintf(char *, const char *, va_list); // #vsprintf
-
-__attribute__((__format__(__printf__, 3, 0)))
-int vsnprintf(char *ch, size_t, const char *, va_list); // #vsnprintf
-
-__attribute__((__format__(__scanf__, 1, 4)))
-void f1(char *out, const size_t len, const char *format, ... /* args */) // #f1
-{
-    va_list args;
-    vsnprintf(out, len, format, args); // expected-no-warning@#f1
-}
-
-__attribute__((__format__(__printf__, 1, 4)))
-void f2(char *out, const size_t len, const char *format, ... /* args */) // #f2
-{
-    va_list args;
-    vsnprintf(out, len, format, args); // expected-warning@#f2 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'f2'}}
-                                       // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:6-[[@LINE-4]]:6}:"__attribute__((format(printf, 3, 4)))"
-}
-
-void f3(char *out, va_list args) // #f3
-{
-    vprintf(out, args); // expected-warning@#f3 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'f3'}}
-                        // CHECK: fix-it:"{{.*}}":{[[@LINE-3]]:6-[[@LINE-3]]:6}:"__attribute__((format(printf, 1, 0)))"
-}
-
-void f4(char* out, ... /* args */) // #f4
-{
-    va_list args;
-    vprintf("test", args); // expected-no-warning@#f4
-
-    const char *ch;
-    vprintf(ch, args); // expected-no-warning@#f4
-}
-
-void f5(va_list args) // #f5
-{
-    char *ch;
-    vscanf(ch, args); // expected-no-warning@#f5
-}
-
-void f6(char *out, va_list args) // #f6
-{
-    char *ch;
-    vprintf(ch, args); // expected-no-warning@#f6
-    vprintf("test", args); // expected-no-warning@#f6
-    vprintf(out, args); // expected-warning@#f6 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'f6'}}
-                        // CHECK: fix-it:"{{.*}}":{[[@LINE-6]]:6-[[@LINE-6]]:6}:"__attribute__((format(printf, 1, 0)))"
-}
-
-void f7(const char *out, ... /* args */) // #f7
-{
-    va_list args;
-
-    vscanf(out, &args[0]); // expected-warning@#f7 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f7'}}
-                           // CHECK: fix-it:"{{.*}}":{[[@LINE-5]]:6-[[@LINE-5]]:6}:"__attribute__((format(scanf, 1, 0)))"
-}
-
-void f8(const char *out, ... /* args */) // #f8
-{
-    va_list args;
-
-    vscanf(out, &args[0]); // expected-no-warning@#f8
-    vprintf(out, &args[0]); // expected-no-warning@#f8
-}
-
-void f9(const char out[], ... /* args */) // #f9
-{
-    va_list args;
-    char *ch;
-    vprintf(ch, args); // expected-no-warning
-    vsprintf(ch, out, args); // expected-warning@#f9 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'f9'}}
-                             // CHECK: fix-it:"{{.*}}":{[[@LINE-6]]:6-[[@LINE-6]]:6}:"__attribute__((format(printf, 1, 2)))"
-}
-
-void f10(const wchar_t *out, ... /* args */) // #f10
-{
-    va_list args;
-    vscanf(out, args);
-#if __SIZEOF_WCHAR_T__ == 4
-                        // c_diagnostics-warning@-2 {{incompatible pointer types passing 'const wchar_t *' (aka 'const int *') to parameter of type 'const char *'}}
-#else
-                        // c_diagnostics-warning@-4 {{incompatible pointer types passing 'const wchar_t *' (aka 'const unsigned short *') to parameter of type 'const char *'}}
-#endif
-                        // c_diagnostics-note@#vscanf {{passing argument to parameter here}}
-                        // c_diagnostics-warning@#f10 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f10'}}
-                        // cpp_diagnostics-error@-8 {{no matching function for call to 'vscanf'}}
-                        // cpp_diagnostics-note@#vscanf {{candidate function not viable: no known conversion from 'const wchar_t *' to 'const char *' for 1st argument}}
-                        // C-CHECK: fix-it:"{{.*}}":{[[@LINE-13]]:6-[[@LINE-13]]:6}:"__attribute__((format(scanf, 1, 2)))"
-}
-
-void f11(const wchar_t *out, ... /* args */) // #f11
-{
-    va_list args;
-    vscanf((const char *) out, args); // expected-warning@#f11 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f11'}}
-                                      // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:6-[[@LINE-4]]:6}:"__attribute__((format(scanf, 1, 2)))"
-}
-
-void f12(const wchar_t *out, ... /* args */) // #f12
-{
-    va_list args;
-    vscanf((char *) out, args); // expected-warning@#f12 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f12'}}
-                                // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:6-[[@LINE-4]]:6}:"__attribute__((format(scanf, 1, 2)))"
-}
-
-void f13(const wchar_t *out, ... /* args */) // #f13
-{
-    va_list args;
-    vscanf(out, args);
-#if __SIZEOF_WCHAR_T__ == 4
-                        // c_diagnostics-warning@-2 {{incompatible pointer types passing 'const wchar_t *' (aka 'const int *') to parameter of type 'const char *'}}
-#else
-                        // c_diagnostics-warning@-4 {{incompatible pointer types passing 'const wchar_t *' (aka 'const unsigned short *') to parameter of type 'const char *'}}
-#endif
-                        // c_diagnostics-note@#vscanf {{passing argument to parameter here}}
-                        // cpp_diagnostics-error@-7 {{no matching function for call to 'vscanf'}}
-                        // cpp_diagnostics-note@#vscanf {{candidate function not viable: no known conversion from 'const wchar_t *' to 'const char *' for 1st argument}}
-                        // expected-warning@#f13 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f13'}}
-                        // CHECK: fix-it:"{{.*}}":{[[@LINE-13]]:6-[[@LINE-13]]:6}:"__attribute__((format(scanf, 1, 2)))"
-    vscanf((const char *) out, args);
-    vscanf((char *) out, args);
-}
-
-void f14(const char *out) // #f14
-{
-    va_list args;
-    vscanf(out, args); // expected-warning@#f14 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f14'}}
-                       // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:6-[[@LINE-4]]:6}:"__attribute__((format(scanf, 1, 0)))"
-}
-
-void f15(const char16_t *out, ... /* args */) // #f15
-{
-    va_list args;
-    vscanf(out, args); // c_diagnostics-warning {{incompatible pointer types passing 'const char16_t *' (aka 'const unsigned short *') to parameter of type 'const char *'}}
-                       // c_diagnostics-note@#vscanf {{passing argument to parameter here}}
-                       // c_diagnostics-warning@#f15 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f15'}}
-                       // C-CHECK: fix-it:"{{.*}}":{[[@LINE-6]]:6-[[@LINE-6]]:6}:"__attribute__((format(scanf, 1, 2)))"
-                       // cpp_diagnostics-error@-4 {{no matching function for call to 'vscanf'}}
-                       // cpp_diagnostics-note@#vscanf {{candidate function not viable: no known conversion from 'const char16_t *' to 'const char *' for 1st argument}}
-}
-
-void f16(const char32_t *out, ... /* args */) // #f16
-{
-    va_list args;
-    vscanf(out, args); // c_diagnostics-warning {{incompatible pointer types passing 'const char32_t *' (aka 'const unsigned int *') to parameter of type 'const char *'}}
-                       // c_diagnostics-note@#vscanf {{passing argument to parameter here}}
-                       // c_diagnostics-warning@#f16 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f16'}}
-                       // C-CHECK: fix-it:"{{.*}}":{[[@LINE-6]]:6-[[@LINE-6]]:6}:"__attribute__((format(scanf, 1, 2)))"
-                       // cpp_diagnostics-error@-4 {{no matching function for call to 'vscanf'}}
-                       // cpp_diagnostics-note@#vscanf {{candidate function not viable: no known conversion from 'const char32_t *' to 'const char *' for 1st argument}}
-}
-
-void f17(const unsigned char *out, ... /* args */) // #f17
-{
-    va_list args;
-    vscanf(out, args); // c_diagnostics-warning {{passing 'const unsigned char *' to parameter of type 'const char *' converts between pointers to integer types where one is of the unique plain 'char' type and the other is not}}
-                       // c_diagnostics-note@#vscanf {{passing argument to parameter here}}
-                       // c_diagnostics-warning@#f17 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f17'}}
-                       // C-CHECK: fix-it:"{{.*}}":{[[@LINE-6]]:6-[[@LINE-6]]:6}:"__attribute__((format(scanf, 1, 2)))"
-                       // cpp_diagnostics-error@-4 {{no matching function for call to 'vscanf'}}
-                       // cpp_diagnostics-note@#vprintf {{candidate function not viable: no known conversion from 'const unsigned char *' to 'const char *' for 1st argument}}
-}
-
-void f18(const unsigned char *out, ... /* args */) // #f18
-{
-    va_list args;
-    vscanf((const char *) out, args); // expected-warning@#f18 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f18'}}
-                                      // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:6-[[@LINE-4]]:6}:"__attribute__((format(scanf, 1, 2)))"
-}
-
-void f19(const unsigned char *out, ... /* args */) // #f19
-{
-    va_list args;
-    vscanf((char *) out, args); // expected-warning@#f19 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f19'}}
-                                // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:6-[[@LINE-4]]:6}:"__attribute__((format(scanf, 1, 2)))"
-}
-
-__attribute__((format(printf, 1, 2)))
-void f20(const unsigned char *out, ... /* args */) // #f20
-{
-    va_list args;
-    vprintf(out, args); // c_diagnostics-warning {{passing 'const unsigned char *' to parameter of type 'const char *' converts between pointers to integer types where one is of the unique plain 'char' type and the other is not}}
-                        // c_diagnostics-note@#vprintf {{passing argument to parameter here}}
-                        // cpp_diagnostics-error@-2 {{no matching function for call to 'vprintf'}}
-                        // cpp_diagnostics-note@#vscanf {{candidate function not viable: no known conversion from 'const unsigned char *' to 'const char *' for 1st argument}}
-    vscanf((const char *) out, args); // expected-no-warning
-    vprintf((const char *) out, args); // expected-no-warning
-    vscanf((char *) out, args); // expected-no-warning
-    vprintf((char *) out, args); // expected-no-warning
-}
-
-void f21(signed char *out, ... /* args */) // #f21
-{
-    va_list args;
-    vscanf(out, args); // c_diagnostics-warning {{passing 'signed char *' to parameter of type 'const char *' converts between pointers to integer types where one is of the unique plain 'char' type and the other is not}} \
-                       // c_diagnostics-note@#vscanf {{passing argument to parameter here}}
-                       // c_diagnostics-warning@#f21 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f21'}}
-                       // C-CHECK: fix-it:"{{.*}}":{[[@LINE-6]]:6-[[@LINE-6]]:6}:"__attribute__((format(scanf, 1, 2)))"
-                       // cpp_diagnostics-error@-4 {{no matching function for call to 'vscanf'}}
-                       // cpp_diagnostics-note@#vscanf {{candidate function not viable: no known conversion from 'signed char *' to 'const char *' for 1st argument}}
-}
-
-void f22(signed char *out, ... /* args */) // #f22
-{
-    va_list args;
-    vscanf((const char *) out, args); // expected-warning@#f22 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f22'}}
-                                      // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:6-[[@LINE-4]]:6}:"__attribute__((format(scanf, 1, 2)))"
-}
-
-void f23(signed char *out, ... /* args */) // #f23
-{
-    va_list args;
-    vprintf((char *) out, args); // expected-warning@#f23 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'f23'}}
-                                 // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:6-[[@LINE-4]]:6}:"__attribute__((format(printf, 1, 2)))"
-}
-
-__attribute__((format(scanf, 1, 2)))
-void f24(signed char *out, ... /* args */) // #f24
-{
-    va_list args;
-    vprintf((const char *) out, args); // expected-no-warning@#f24
-    vprintf((char *) out, args); // expected-no-warning@#f24
-}
-
-__attribute__((format(printf, 1, 2)))
-void f25(unsigned char out[], ... /* args */) // #f25
-{
-    va_list args;
-    vscanf((const char *) out, args); // expected-no-warning@#f25
-    vscanf((char *) out, args); // expected-no-warning@#f25
-}
-
-void f26(char* out) // #f26
-{
-    va_list args;
-    const char* ch;
-    vsprintf(out, ch, args); // expected-no-warning@#f26
-    vprintf(out, args); // expected-warning@#f26 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'f26'}}
-                        // CHECK: fix-it:"{{.*}}":{[[@LINE-6]]:6-[[@LINE-6]]:6}:"__attribute__((format(printf, 1, 0)))"
-}
-
-void f27(const char *out, ... /* args */) // #f27
-{
-    int a;
-    printf(out, a); // expected-warning@#f27 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'f27'}}
-                    // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:6-[[@LINE-4]]:6}:"__attribute__((format(printf, 1, 0)))"
-}
-
-void f28(const char *out, ... /* args */) // #f28
-{
-    printf(out, 1); // expected-warning@#f28 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'f28'}}
-                    // CHECK: fix-it:"{{.*}}":{[[@LINE-3]]:6-[[@LINE-3]]:6}:"__attribute__((format(printf, 1, 0)))"
-}
-
-__attribute__((format(printf, 1, 2)))
-void f29(const char *out, ... /* args */) // #f29
-{
-    int a;
-    printf(out, a); // expected-no-warning@#f29
-}
-
-__attribute__((format(printf, 1, 2)))
-void f30(const char *out, ... /* args */) // #f30
-{
-    printf(out, 1); // expected-no-warning@#f30
-}
-
-__attribute__((format(printf, 1, 2)))
-void f31(const char *out, ... /* args */) // #f31
-{
-    int a;
-    printf(out, a); // expected-no-warning@#f31
-    printf(out, 1); // expected-no-warning@#f31
-}
-
-void f32(char *out, ... /* args */) // #f32
-{
-    va_list args;
-    scanf(out, args); // expected-no-warning@#f32
-    {
-        printf(out, args); // expected-no-warning@#f32
-    }
-}
-
-void f33(char *out, va_list args) // #f33
-{
-    {
-        scanf(out, args); // expected-no-warning@#f33
-        printf(out, args); // expected-no-warning@#f33
-    }
-}
-
-// expected-warning@#f34 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f34'}}
-// CHECK: fix-it:"{{.*}}":{[[@LINE+1]]:6-[[@LINE+1]]:6}:"__attribute__((format(scanf, 1, 2)))"
-void f34(char *out, ... /* args */) // #f34
-{
-    va_list args;
-    scanf(out, args); // expected-no-warning@#f34
-    {
-        scanf(out, args); // expected-no-warning@#f34
-    }
-}
-
-void f35(char* ch, const char *out, ... /* args */) // #f35
-{
-    va_list args;
-    printf(ch, args); // expected-warning@#f35 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'f35}}
-                      // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:6-[[@LINE-4]]:6}:"__attribute__((format(printf, 1, 3)))"
-    int a;
-    printf(out, a); // expected-warning@#f35 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'f35'}}
-                    // CHECK: fix-it:"{{.*}}":{[[@LINE-7]]:6-[[@LINE-7]]:6}:"__attribute__((format(printf, 2, 0)))"
-    printf(out, 1); // no warning because first command above emitted same warning with same fix-it text
-    printf(out, args); // expected-warning@#f35 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'f35'}}
-                       // CHECK: fix-it:"{{.*}}":{[[@LINE-10]]:6-[[@LINE-10]]:6}:"__attribute__((format(printf, 2, 3)))"
-}
-
-typedef va_list tdVaList;
-typedef int tdInt;
-
-void f36(const char *out, ... /* args */) // #f36
-{
-    tdVaList args;
-    printf(out, args); // expected-warning@#f36 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'f36'}}
-                       // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:6-[[@LINE-4]]:6}:"__attribute__((format(printf, 1, 2)))"
-}
-
-void f37(const char *out, ... /* args */) // #f37
-{
-    tdInt a;
-    scanf(out, a); // expected-warning@#f37 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f37'}}
-                   // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:6-[[@LINE-4]]:6}:"__attribute__((format(scanf, 1, 0)))"
-}
-
-void f38(const char *out, tdVaList args) // #f38
-{
-    scanf(out, args); // expected-warning@#f38 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'f38'}}
-                      // CHECK: fix-it:"{{.*}}":{[[@LINE-3]]:6-[[@LINE-3]]:6}:"__attribute__((format(scanf, 1, 0)))"
-}
-
-void f39(const char *out, tdVaList args) // #f39
-{
-    tdInt a;
-    printf(out, a); // expected-warning@#f39 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'f39'}}
-                    // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:6-[[@LINE-4]]:6}:"__attribute__((format(printf, 1, 0)))"
-}
-
-void f40(char *out, ... /* args */) // #f40
-{
-    va_list args;
-    char *ch;
-    vscanf(ch, args); // expected-no-warning@#f40
-    vprintf(out, args); // expected-no-warning@#f40
-}
-
-void f41(char *out, ... /* args */) // #f41
-{
-    va_list args;
-    char *ch;
-    vscanf("%s", ch);
-#if defined(__x86_64__) && defined(__linux__)
-                        // c_diagnostics-warning@-2 {{incompatible pointer types passing 'char *' to parameter of type 'struct __va_list_tag *'}}
-                        // c_diagnostics-note@#vscanf {{passing argument to parameter here}}
-                        // cpp_diagnostics-error@-4 {{no matching function for call to 'vscanf'}}
-                        // cpp_diagnostics-note@#vscanf {{candidate function not viable: no known conversion from 'char *' to '__va_list_tag *' for 2nd argument}}
-#endif
-    vprintf(out, args);
-#if defined(__x86_64__) && defined(__linux__)
-                        // cpp_diagnostics-warning@#f41 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'f41'}}
-                        // CHECK-LIN64: fix-it:"{{.*}}":{[[@LINE-14]]:6-[[@LINE-14]]:6}:"__attribute__((format(printf, 1, 2)))"
-#endif
-}
diff -ruN --strip-trailing-cr a/clang/test/Sema/attr-format-missing.cpp b/clang/test/Sema/attr-format-missing.cpp
--- a/clang/test/Sema/attr-format-missing.cpp
+++ b/clang/test/Sema/attr-format-missing.cpp
@@ -1,174 +0,0 @@
-// RUN: %clang_cc1 -fsyntax-only -verify=expected,beforeCxx2b -Wmissing-format-attribute %s
-// RUN: %clang_cc1 -fsyntax-only -verify -std=c++2b -Wmissing-format-attribute %s
-// RUN: %clang_cc1 -fsyntax-only -verify -std=c++23 -Wmissing-format-attribute %s
-// RUN: not %clang_cc1 -fsyntax-only -Wmissing-format-attribute -fdiagnostics-parseable-fixits %s 2>&1 | FileCheck %s
-
-typedef __SIZE_TYPE__ size_t;
-typedef __builtin_va_list va_list;
-
-namespace std
-{
-    template<class Elem> struct basic_string_view {};
-    template<class Elem> struct basic_string {
-        const Elem *c_str() const noexcept;
-        basic_string(const basic_string_view<Elem> SW);
-    };
-
-    using string = basic_string<char>;
-    using wstring = basic_string<wchar_t>;
-    using string_view = basic_string_view<char>;
-    using wstring_view = basic_string_view<wchar_t>;
-}
-
-__attribute__((__format__(__printf__, 1, 2)))
-int printf(const char *, ...); // #printf
-
-__attribute__((__format__(__scanf__, 1, 2)))
-int scanf(const char *, ...); // #scanf
-
-__attribute__((__format__(__printf__, 1, 0)))
-int vprintf(const char *, va_list); // #vprintf
-
-__attribute__((__format__(__scanf__, 1, 0)))
-int vscanf(const char *, va_list); // #vscanf
-
-__attribute__((__format__(__printf__, 2, 0)))
-int vsprintf(char *, const char *, va_list); // #vsprintf
-
-__attribute__((__format__(__printf__, 3, 0)))
-int vsnprintf(char *ch, size_t, const char *, va_list); // #vsnprintf
-
-void f1(const std::string &str, ... /* args */) // #f1
-{
-    va_list args;
-    vscanf(str.c_str(), args); // expected-no-warning@#f1
-}
-
-__attribute__((format(printf, 1, 2))) // expected-error {{format argument not a string type}}
-void f2(const std::string &str, ... /* args */); // #f2
-
-void f3(std::string_view str, ... /* args */) // #f3
-{
-    va_list args;
-    vscanf(std::string(str).c_str(), args); // expected-no-warning@#f3
-}
-
-__attribute__((format(printf, 1, 2))) // expected-error {{format argument not a string type}}
-void f4(std::string_view str, ... /* args */); // #f4
-
-void f5(const std::wstring &str, ... /* args */) // #f5
-{
-    va_list args;
-    vprintf((const char *)str.c_str(), args); // expected-no-warning@#f5
-}
-
-__attribute__((format(printf, 1, 2))) // expected-error {{format argument not a string type}}
-void f6(const std::wstring &str, ... /* args */); // #f6
-
-void f7(std::wstring_view str, ... /* args */) // #f7
-{
-    va_list args;
-    vprintf((const char *) std::wstring(str).c_str(), args); // expected-no-warning@#f7
-}
-
-__attribute__((format(printf, 1, 2))) // expected-error {{format argument not a string type}}
-void f8(std::wstring_view str, ... /* args */); // #f8
-
-struct S1
-{
-    void fn1(const char *out, ... /* args */) // #S1_fn1
-    {
-        va_list args;
-        vscanf(out, args); // expected-warning@#S1_fn1 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'fn1'}}
-                           // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:10-[[@LINE-4]]:10}:"__attribute__((format(scanf, 2, 3)))"
-    }
-
-    __attribute__((format(scanf, 2, 0)))
-    void fn2(const char *out, va_list args); // #S1_fn2
-
-    void fn3(const char *out, ... /* args */);
-
-    void fn4(this S1& expliciteThis, const char *out, va_list args) // #S1_fn4
-    {
-        expliciteThis.fn2(out, args); // beforeCxx2b-error@#S1_fn4 {{explicit object parameters are incompatible with C++ standards before C++2b}}
-                                      // expected-warning@#S1_fn4 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'fn4'}}
-                                      // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:10-[[@LINE-4]]:10}:"__attribute__((format(scanf, 2, 0)))"
-    }
-};
-
-void S1::fn3(const char *out, ... /* args */) // #S1_fn3
-{
-    va_list args;
-    fn2(out, args); // expected-warning@#S1_fn3 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'fn3'}}
-                    // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:10-[[@LINE-4]]:10}:"__attribute__((format(scanf, 2, 3)))"
-}
-
-union U1
-{
-    __attribute__((format(printf, 2, 0)))
-    void fn1(const char *out, va_list args); // #U1_fn1
-
-    void fn2(const char *out, ... /* args */) // #U1_fn2
-    {
-        va_list args;
-        fn1(out, args); // expected-warning@#U1_fn2 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'fn2'}}
-                        // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:10-[[@LINE-4]]:10}:"__attribute__((format(printf, 2, 3)))"
-    }
-
-    void fn3(this U1&, const char *out) // #U1_fn3
-    {
-        va_list args;
-        printf(out, args); // beforeCxx2b-error@#U1_fn3 {{explicit object parameters are incompatible with C++ standards before C++2b}}
-                           // expected-warning@#U1_fn3 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'fn3'}}
-                           // CHECK: fix-it:"{{.*}}":{[[@LINE-5]]:10-[[@LINE-5]]:10}:"__attribute__((format(printf, 2, 0)))"
-    }
-};
-
-class C1
-{
-    __attribute__((format(printf, 3, 0)))
-    void fn1(const int n, const char *out, va_list args); // #C1_fn1
-
-    void fn2(const char *out, const int n, ... /* args */) // #C1_fn2
-    {
-        va_list args;
-        fn1(n, out, args); // expected-warning@#C1_fn2 {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'fn2'}}
-                           // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:10-[[@LINE-4]]:10}:"__attribute__((format(printf, 2, 4)))"
-    }
-
-    void fn3(this const C1&, const char *out, va_list args) // #C1_fn3
-    {
-        scanf(out, args); // beforeCxx2b-error@#C1_fn3 {{explicit object parameters are incompatible with C++ standards before C++2b}}
-                          // expected-warning@#C1_fn3 {{diagnostic behavior may be improved by adding the 'scanf' format attribute to the declaration of 'fn3'}}
-                          // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:10-[[@LINE-4]]:10}:"__attribute__((format(scanf, 2, 0)))"
-    }
-
-    C1(const int n, const char *out) //#C1_C1a
-    {
-        va_list args;
-        fn1(n, out, args); // expected-warning@#C1_C1a {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'C1'}}
-                           // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:5-[[@LINE-4]]:5}:"__attribute__((format(printf, 3, 0)))"
-    }
-
-    C1(const char *out, ... /* args */) // #C1_C1b
-    {
-        va_list args;
-        printf(out, args); // expected-warning@#C1_C1b {{diagnostic behavior may be improved by adding the 'printf' format attribute to the declaration of 'C1'}}
-                           // CHECK: fix-it:"{{.*}}":{[[@LINE-4]]:5-[[@LINE-4]]:5}:"__attribute__((format(printf, 2, 3)))"
-    }
-
-    ~C1() // #d_C1
-    {
-        const char *out;
-        va_list args;
-        vprintf(out, args); // expected-no-warning@#d_C1
-    }
-};
-
-// TODO: implement for templates
-template <int N>
-void func(char (&str)[N], ... /* args */) // #func
-{
-    va_list args;
-    vprintf(str, args); // expected-no-warning@#func
-}
diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/cxx0x-noexcept-expression.cpp b/clang/test/SemaCXX/cxx0x-noexcept-expression.cpp
--- a/clang/test/SemaCXX/cxx0x-noexcept-expression.cpp
+++ b/clang/test/SemaCXX/cxx0x-noexcept-expression.cpp
@@ -127,7 +127,7 @@
   // `dependent` should be type-dependent because the noexcept-expression should be value-dependent
   // (it is true if T is int*, false if T is Polymorphic<false, false>* for example)
   dependent.f<void>();  // This should need to be `.template f` to parse as a template
-  // expected-warning@-1 {{use 'template' keyword to treat 'f' as a dependent template name}}
+  // expected-error@-1 {{use 'template' keyword to treat 'f' as a dependent template name}}
 }
 template<typename... T>
 void f2() {
@@ -135,14 +135,14 @@
   // X<true> when T...[0] is a type with some operator&& which returns int*
   // X<false> when sizeof...(T) == 0
   dependent.f<void>();
-  // expected-warning@-1 {{use 'template' keyword to treat 'f' as a dependent template name}}
+  // expected-error@-1 {{use 'template' keyword to treat 'f' as a dependent template name}}
 }
 template<typename T>
 void f3() {
   X<noexcept(typeid(*static_cast<T*>(nullptr)))> dependent;
   // X<true> when T is int, X<false> when T is Polymorphic<false, false>
   dependent.f<void>();
-  // expected-warning@-1 {{use 'template' keyword to treat 'f' as a dependent template name}}
+  // expected-error@-1 {{use 'template' keyword to treat 'f' as a dependent template name}}
 }
 template<typename T>
 void f4() {
diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/pseudo-destructors.cpp b/clang/test/SemaCXX/pseudo-destructors.cpp
--- a/clang/test/SemaCXX/pseudo-destructors.cpp
+++ b/clang/test/SemaCXX/pseudo-destructors.cpp
@@ -22,21 +22,21 @@
 void f(A* a, Foo *f, int *i, double *d, int ii) {
   a->~A();
   a->A::~A();
-
+  
   a->~foo(); // expected-error{{undeclared identifier 'foo' in destructor name}}
-
+  
   a->~Bar(); // expected-error{{destructor type 'Bar' (aka 'Foo') in object destruction expression does not match the type 'A' of the object being destroyed}}
-
+  
   f->~Bar();
   f->~Foo();
   i->~Bar(); // expected-error{{does not match}}
-
+  
   g().~Bar(); // expected-error{{non-scalar}}
-
+  
   f->::~Bar(); // expected-error {{not a structure or union}}
   f->::Bar::~Bar();
   f->N::~Wibble(); // expected-error{{'N' does not refer to a type}} expected-error{{'Wibble' does not refer to a type}}
-
+  
   f->Bar::~Bar(17, 42); // expected-error{{cannot have any arguments}}
 
   i->~Integer();
@@ -148,12 +148,12 @@
   namespace Template {
     template<typename T> struct Y {};
     template<class U> using G = Y<U>;
-    template<typename T> void f(T *p) { p->~G<int>(); } // expected-error {{no member named 'G'}}
+    template<typename T> void f(T *p) { p->~G<int>(); } // expected-error {{no member named '~Y'}}
     void h1(Y<int> *p) { p->~G<int>(); }
-    void h2(Y<int> *p) { f(p); } // expected-note {{instantiation of}}
+    void h2(Y<int> *p) { f(p); }
     namespace N { template<typename T> struct G {}; }
     void h3(N::G<int> *p) { p->~G<int>(); }
-    void h4(N::G<int> *p) { f(p); }
+    void h4(N::G<int> *p) { f(p); } // expected-note {{instantiation of}}
   }
 
   namespace TemplateUndeclared {
diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/static-assert-cxx17.cpp b/clang/test/SemaCXX/static-assert-cxx17.cpp
--- a/clang/test/SemaCXX/static-assert-cxx17.cpp
+++ b/clang/test/SemaCXX/static-assert-cxx17.cpp
@@ -96,7 +96,7 @@
   // expected-error@-1{{static assertion failed due to requirement 'static_cast<const X<int> *>(nullptr)'}}
   static_assert((const X<typename T::T>[]){} == nullptr);
   // expected-error@-1{{static assertion failed due to requirement '(const X<int>[0]){} == nullptr'}}
-  static_assert(sizeof(X<decltype(X<typename T::T>().template X<typename T::T>::~X())>) == 0);
+  static_assert(sizeof(X<decltype(X<typename T::T>().X<typename T::T>::~X())>) == 0);
   // expected-error@-1{{static assertion failed due to requirement 'sizeof(X<void>) == 0'}} \
   // expected-note@-1 {{evaluates to '8 == 0'}}
   static_assert(constexpr_return_false<typename T::T, typename T::U>());
diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/dependent-base-classes.cpp b/clang/test/SemaTemplate/dependent-base-classes.cpp
--- a/clang/test/SemaTemplate/dependent-base-classes.cpp
+++ b/clang/test/SemaTemplate/dependent-base-classes.cpp
@@ -1,12 +1,12 @@
 // RUN: %clang_cc1 -fsyntax-only -verify %s
 
 template<typename T, typename U>
-struct X0 : T::template apply<U> {
+struct X0 : T::template apply<U> { 
   X0(U u) : T::template apply<U>(u) { }
 };
 
 template<typename T, typename U>
-struct X1 : T::apply<U> { }; // expected-warning{{use 'template' keyword to treat 'apply' as a dependent template name}}
+struct X1 : T::apply<U> { }; // expected-error{{use 'template' keyword to treat 'apply' as a dependent template name}}
 
 template<typename T>
 struct X2 : vector<T> { }; // expected-error{{no template named 'vector'}}
@@ -85,7 +85,7 @@
   struct A { };
 
   template<typename T>
-  class B : public A<T>
+  class B : public A<T> 
   {
   public:
     template< class X >
@@ -109,9 +109,9 @@
 
 namespace PR6413 {
   template <typename T> class Base_A { };
-
+  
   class Base_B { };
-
+  
   template <typename T>
   class Derived
     : public virtual Base_A<T>
@@ -120,12 +120,12 @@
 }
 
 namespace PR5812 {
-  template <class T> struct Base {
-    Base* p;
-  };
+  template <class T> struct Base { 
+    Base* p; 
+  }; 
 
-  template <class T> struct Derived: public Base<T> {
-    typename Derived::Base* p; // meaning Derived::Base<T>
+  template <class T> struct Derived: public Base<T> { 
+    typename Derived::Base* p; // meaning Derived::Base<T> 
   };
 
   Derived<int> di;
diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/dependent-template-recover.cpp b/clang/test/SemaTemplate/dependent-template-recover.cpp
--- a/clang/test/SemaTemplate/dependent-template-recover.cpp
+++ b/clang/test/SemaTemplate/dependent-template-recover.cpp
@@ -2,15 +2,15 @@
 template<typename T, typename U, int N>
 struct X {
   void f(T* t) {
-    t->f0<U>(); // expected-warning{{use 'template' keyword to treat 'f0' as a dependent template name}}
-    t->f0<int>(); // expected-warning{{use 'template' keyword to treat 'f0' as a dependent template name}}
+    t->f0<U>(); // expected-error{{use 'template' keyword to treat 'f0' as a dependent template name}}
+    t->f0<int>(); // expected-error{{use 'template' keyword to treat 'f0' as a dependent template name}}
 
-    t->operator+<U const, 1>(1); // expected-warning{{use 'template' keyword to treat 'operator +' as a dependent template name}}
-    t->f1<int const, 2>(1); // expected-warning{{use 'template' keyword to treat 'f1' as a dependent template name}}
+    t->operator+<U const, 1>(1); // expected-error{{use 'template' keyword to treat 'operator +' as a dependent template name}}
+    t->f1<int const, 2>(1); // expected-error{{use 'template' keyword to treat 'f1' as a dependent template name}}
     t->f1<3, int const>(1); // expected-error{{missing 'template' keyword prior to dependent template name 'f1'}}
 
-    T::getAs<U>(); // expected-warning{{use 'template' keyword to treat 'getAs' as a dependent template name}}
-    t->T::getAs<U>(); // expected-warning{{use 'template' keyword to treat 'getAs' as a dependent template name}}
+    T::getAs<U>(); // expected-error{{use 'template' keyword to treat 'getAs' as a dependent template name}}
+    t->T::getAs<U>(); // expected-error{{use 'template' keyword to treat 'getAs' as a dependent template name}}
 
     (*t).f2<N>(); // expected-error{{missing 'template' keyword prior to dependent template name 'f2'}}
     (*t).f2<0>(); // expected-error{{missing 'template' keyword prior to dependent template name 'f2'}}
diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/temp_arg_nontype_cxx20.cpp b/clang/test/SemaTemplate/temp_arg_nontype_cxx20.cpp
--- a/clang/test/SemaTemplate/temp_arg_nontype_cxx20.cpp
+++ b/clang/test/SemaTemplate/temp_arg_nontype_cxx20.cpp
@@ -115,7 +115,7 @@
   static_assert(f(X<A{}>()) == 0);
 
   template<A a> struct Y { void f(); };
-  template<A a> void g(Y<a> y) { y.template Y<a>::f(); }
+  template<A a> void g(Y<a> y) { y.Y<a>::f(); }
   void h() { constexpr A a; g<a>(Y<a>{}); }
 
   template<A a> struct Z {
diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/template-id-expr.cpp b/clang/test/SemaTemplate/template-id-expr.cpp
--- a/clang/test/SemaTemplate/template-id-expr.cpp
+++ b/clang/test/SemaTemplate/template-id-expr.cpp
@@ -19,7 +19,7 @@
 struct X0 {
   template<typename U>
   void f1();
-
+  
   template<typename U>
   void f2(U) {
     f1<U>();
@@ -39,9 +39,9 @@
 template<int I>
 struct X {
   X(int, int);
-  void f() {
-    Y<X<I> >(X<I>(0, 0));
-    Y<X<I> >(::X<I>(0, 0));
+  void f() { 
+    Y<X<I> >(X<I>(0, 0)); 
+    Y<X<I> >(::X<I>(0, 0)); 
   }
 };
 
@@ -149,11 +149,11 @@
 
     int x;
     x = Y1::f4(0);
-    x = Y1::f4<int>(0); // expected-warning {{use 'template'}} expected-error {{assigning to 'int' from incompatible type 'void'}}
+    x = Y1::f4<int>(0); // expected-error {{use 'template'}} expected-error {{assigning to 'int' from incompatible type 'void'}}
     x = Y1::template f4(0); // expected-error {{assigning to 'int' from incompatible type 'void'}} expected-error {{a template argument list is expected after a name prefixed by the template keyword}}
 
     x = p->f4(0);
-    x = p->f4<int>(0); // expected-error {{assigning to 'int' from incompatible type 'void'}} expected-warning {{use 'template'}}
+    x = p->f4<int>(0); // expected-error {{assigning to 'int' from incompatible type 'void'}} expected-error {{use 'template'}}
     x = p->template f4(0); // expected-error {{assigning to 'int' from incompatible type 'void'}} expected-error {{a template argument list is expected after a name prefixed by the template keyword}}
   }
 };
@@ -184,7 +184,7 @@
 #if __cplusplus <= 199711L
 // expected-warning@+2 {{extension}}
 #endif
-template<typename T> using D = int; // expected-note {{declared here}}
+template<typename T> using D = int; // expected-note {{declared here}} 
 E<D> ed; // expected-note {{instantiation of}}
 
 namespace non_functions {
diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/typename-specifier-3.cpp b/clang/test/SemaTemplate/typename-specifier-3.cpp
--- a/clang/test/SemaTemplate/typename-specifier-3.cpp
+++ b/clang/test/SemaTemplate/typename-specifier-3.cpp
@@ -46,7 +46,7 @@
       typedef int arg;
     };
     struct C {
-      typedef typename B::X<typename B::arg> x; // expected-warning {{use 'template'}} expected-error {{refers to non-type}}
+      typedef typename B::X<typename B::arg> x; // expected-error {{use 'template'}} expected-error {{refers to non-type}}
     };
   };
 
diff -ruN --strip-trailing-cr a/libcxx/include/regex b/libcxx/include/regex
--- a/libcxx/include/regex
+++ b/libcxx/include/regex
@@ -4214,7 +4214,7 @@
   _LIBCPP_HIDE_FROM_ABI int compare(const value_type* __s) const { return str().compare(__s); }
 
   _LIBCPP_HIDE_FROM_ABI void swap(sub_match& __s) _NOEXCEPT_(__is_nothrow_swappable_v<_BidirectionalIterator>) {
-    this->template pair<_BidirectionalIterator, _BidirectionalIterator>::swap(__s);
+    this->pair<_BidirectionalIterator, _BidirectionalIterator>::swap(__s);
     std::swap(matched, __s.matched);
   }
 };
diff -ruN --strip-trailing-cr a/llvm/include/llvm/ADT/ArrayRef.h b/llvm/include/llvm/ADT/ArrayRef.h
--- a/llvm/include/llvm/ADT/ArrayRef.h
+++ b/llvm/include/llvm/ADT/ArrayRef.h
@@ -460,11 +460,8 @@
 
     OwningArrayRef &operator=(OwningArrayRef &&Other) {
       delete[] this->data();
-      using Base = MutableArrayRef<T>;
-      // GCC versions prior to 11.1 incorrectly reject if the 'template' keyword
-      // is used prior to the nested-name-specifier here.
-      this->Base::operator=(Other);
-      Other.Base::operator=(Base());
+      this->MutableArrayRef<T>::operator=(Other);
+      Other.MutableArrayRef<T>::operator=(MutableArrayRef<T>());
       return *this;
     }
 
diff -ruN --strip-trailing-cr a/llvm/lib/CodeGen/MachineSink.cpp b/llvm/lib/CodeGen/MachineSink.cpp
--- a/llvm/lib/CodeGen/MachineSink.cpp
+++ b/llvm/lib/CodeGen/MachineSink.cpp
@@ -961,7 +961,7 @@
                                                 MachineBasicBlock *ToBB,
                                                 bool BreakPHIEdge) {
   // Avoid breaking back edge. From == To means backedge for single BB cycle.
-  if (!SplitEdges || FromBB == ToBB)
+  if (!SplitEdges || FromBB == ToBB || !FromBB->isSuccessor(ToBB))
     return false;
 
   MachineCycle *FromCycle = CI->getCycle(FromBB);
diff -ruN --strip-trailing-cr a/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp b/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp
--- a/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp
+++ b/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp
@@ -128,7 +128,6 @@
   bool visitINSviGPR(MachineInstr &MI, unsigned Opc);
   bool visitINSvi64lane(MachineInstr &MI);
   bool visitFMOVDr(MachineInstr &MI);
-  bool visitCopy(MachineInstr &MI);
   bool runOnMachineFunction(MachineFunction &MF) override;
 
   StringRef getPassName() const override {
@@ -691,34 +690,6 @@
   return true;
 }
 
-// Across a basic-block we might have in i32 extract from a value that only
-// operates on upper bits (for example a sxtw). We can replace the COPY with a
-// new version skipping the sxtw.
-bool AArch64MIPeepholeOpt::visitCopy(MachineInstr &MI) {
-  Register InputReg = MI.getOperand(1).getReg();
-  if (MI.getOperand(1).getSubReg() != AArch64::sub_32 ||
-      !MRI->hasOneNonDBGUse(InputReg))
-    return false;
-
-  MachineInstr *SrcMI = MRI->getUniqueVRegDef(InputReg);
-  MachineInstr *CopyMI = SrcMI;
-  while (SrcMI && SrcMI->isFullCopy() &&
-         MRI->hasOneNonDBGUse(SrcMI->getOperand(1).getReg()))
-    SrcMI = MRI->getUniqueVRegDef(SrcMI->getOperand(1).getReg());
-
-  if (!SrcMI || SrcMI->getOpcode() != AArch64::SBFMXri ||
-      SrcMI->getOperand(2).getImm() != 0 || SrcMI->getOperand(3).getImm() != 31)
-    return false;
-
-  Register SrcReg = SrcMI->getOperand(1).getReg();
-  MRI->constrainRegClass(SrcReg, MRI->getRegClass(InputReg));
-  MI.getOperand(1).setReg(SrcReg);
-  if (CopyMI != SrcMI)
-    CopyMI->eraseFromParent();
-  SrcMI->eraseFromParent();
-  return true;
-}
-
 bool AArch64MIPeepholeOpt::runOnMachineFunction(MachineFunction &MF) {
   if (skipFunction(MF.getFunction()))
     return false;
@@ -800,9 +771,6 @@
       case AArch64::FMOVDr:
         Changed |= visitFMOVDr(MI);
         break;
-      case AArch64::COPY:
-        Changed |= visitCopy(MI);
-        break;
       }
     }
   }
diff -ruN --strip-trailing-cr a/llvm/lib/Target/AArch64/peephole-sxtw.mir b/llvm/lib/Target/AArch64/peephole-sxtw.mir
--- a/llvm/lib/Target/AArch64/peephole-sxtw.mir
+++ b/llvm/lib/Target/AArch64/peephole-sxtw.mir
@@ -1,46 +0,0 @@
-# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
-# RUN: llc -run-pass=aarch64-mi-peephole-opt -o - -mtriple=aarch64-unknown-linux -verify-machineinstrs %s | FileCheck %s
-
----
-name: removeSxtw
-tracksRegLiveness: true
-body: |
-  bb.0.entry:
-    liveins: $x0
-    ; CHECK-LABEL: name: removeSxtw
-    ; CHECK: liveins: $x0
-    ; CHECK-NEXT: {{  $}}
-    ; CHECK-NEXT: [[COPY:%[0-9]+]]:gpr64 = COPY $x0
-    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:gpr32sp = COPY [[COPY]].sub_32
-    ; CHECK-NEXT: [[ADDWri:%[0-9]+]]:gpr32sp = ADDWri [[COPY1]], 1, 0
-    ; CHECK-NEXT: $w0 = COPY [[ADDWri]]
-    ; CHECK-NEXT: RET_ReallyLR implicit $w0
-    %0:gpr64 = COPY $x0
-    %1:gpr64 = SBFMXri %0:gpr64, 0, 31
-    %2:gpr32sp = COPY %1.sub_32:gpr64
-    %3:gpr32sp = ADDWri %2:gpr32sp, 1, 0
-    $w0 = COPY %3:gpr32sp
-    RET_ReallyLR implicit $w0
-...
----
-name: extraCopy
-tracksRegLiveness: true
-body: |
-  bb.0.entry:
-    liveins: $x0
-    ; CHECK-LABEL: name: extraCopy
-    ; CHECK: liveins: $x0
-    ; CHECK-NEXT: {{  $}}
-    ; CHECK-NEXT: [[COPY:%[0-9]+]]:gpr64 = COPY $x0
-    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:gpr32sp = COPY [[COPY]].sub_32
-    ; CHECK-NEXT: [[ADDWri:%[0-9]+]]:gpr32sp = ADDWri [[COPY1]], 1, 0
-    ; CHECK-NEXT: $w0 = COPY [[ADDWri]]
-    ; CHECK-NEXT: RET_ReallyLR implicit $w0
-    %0:gpr64 = COPY $x0
-    %1:gpr64 = SBFMXri %0:gpr64, 0, 31
-    %2:gpr64all = COPY %1:gpr64
-    %3:gpr32sp = COPY %2.sub_32:gpr64all
-    %4:gpr32sp = ADDWri %3:gpr32sp, 1, 0
-    $w0 = COPY %4:gpr32sp
-    RET_ReallyLR implicit $w0
-...
diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
@@ -2493,8 +2493,9 @@
       auto *I = cast<Instruction>(V);
       DeletedInstructions.insert(I);
     }
+    DenseSet<Value *> Processed;
     for (T *V : DeadVals) {
-      if (!V)
+      if (!V || !Processed.insert(V).second)
         continue;
       auto *I = cast<Instruction>(V);
       salvageDebugInfo(*I);
diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/AArch64/aarch64-mull-masks.ll b/llvm/test/CodeGen/AArch64/aarch64-mull-masks.ll
--- a/llvm/test/CodeGen/AArch64/aarch64-mull-masks.ll
+++ b/llvm/test/CodeGen/AArch64/aarch64-mull-masks.ll
@@ -281,7 +281,8 @@
 ; CHECK-LABEL: smull_ldrsw_shift:
 ; CHECK:       // %bb.0: // %entry
 ; CHECK-NEXT:    ldrsw x8, [x0]
-; CHECK-NEXT:    smull x0, w8, w1
+; CHECK-NEXT:    sxtw x9, w1
+; CHECK-NEXT:    smull x0, w8, w9
 ; CHECK-NEXT:    ret
 entry:
   %ext64 = load i32, ptr %x0
@@ -489,7 +490,8 @@
 ; CHECK-LABEL: smaddl_ldrsw_shift:
 ; CHECK:       // %bb.0: // %entry
 ; CHECK-NEXT:    ldrsw x8, [x0]
-; CHECK-NEXT:    smaddl x0, w8, w1, x2
+; CHECK-NEXT:    sxtw x9, w1
+; CHECK-NEXT:    smaddl x0, w8, w9, x2
 ; CHECK-NEXT:    ret
 entry:
   %ext64 = load i32, ptr %x0
@@ -652,7 +654,8 @@
 ; CHECK-LABEL: smnegl_ldrsw_shift:
 ; CHECK:       // %bb.0: // %entry
 ; CHECK-NEXT:    ldrsw x8, [x0]
-; CHECK-NEXT:    smnegl x0, w8, w1
+; CHECK-NEXT:    sxtw x9, w1
+; CHECK-NEXT:    smnegl x0, w8, w9
 ; CHECK-NEXT:    ret
 entry:
   %ext64 = load i32, ptr %x0
@@ -815,7 +818,8 @@
 ; CHECK-LABEL: smsubl_ldrsw_shift:
 ; CHECK:       // %bb.0: // %entry
 ; CHECK-NEXT:    ldrsw x8, [x0]
-; CHECK-NEXT:    smsubl x0, w8, w1, x2
+; CHECK-NEXT:    sxtw x9, w1
+; CHECK-NEXT:    smsubl x0, w8, w9, x2
 ; CHECK-NEXT:    ret
 entry:
   %ext64 = load i32, ptr %x0
diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/X86/MachineSink-Issue98477.ll b/llvm/test/CodeGen/X86/MachineSink-Issue98477.ll
--- a/llvm/test/CodeGen/X86/MachineSink-Issue98477.ll
+++ b/llvm/test/CodeGen/X86/MachineSink-Issue98477.ll
@@ -0,0 +1,76 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
+; RUN: llc < %s | FileCheck %s
+
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-unknown-linux-gnu"
+
+define i32 @main(i1 %tobool.not, i32 %0) {
+; CHECK-LABEL: main:
+; CHECK:       # %bb.0: # %entry
+; CHECK-NEXT:    movl $1, %r8d
+; CHECK-NEXT:    testb $1, %dil
+; CHECK-NEXT:    jne .LBB0_8
+; CHECK-NEXT:  .LBB0_1: # %j.preheader
+; CHECK-NEXT:    xorl %r9d, %r9d
+; CHECK-NEXT:    jmp .LBB0_2
+; CHECK-NEXT:    .p2align 4, 0x90
+; CHECK-NEXT:  .LBB0_5: # %if.then4
+; CHECK-NEXT:    # in Loop: Header=BB0_2 Depth=1
+; CHECK-NEXT:    movl $1, %eax
+; CHECK-NEXT:    xorl %edx, %edx
+; CHECK-NEXT:    divl %r8d
+; CHECK-NEXT:    testb $1, %dil
+; CHECK-NEXT:    jne .LBB0_6
+; CHECK-NEXT:  .LBB0_2: # %j
+; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
+; CHECK-NEXT:    movl $1, %eax
+; CHECK-NEXT:    xorl %edx, %edx
+; CHECK-NEXT:    idivl %esi
+; CHECK-NEXT:    movl %edx, %ecx
+; CHECK-NEXT:    testb %r9b, %r9b
+; CHECK-NEXT:    jne .LBB0_5
+; CHECK-NEXT:  # %bb.3: # %j
+; CHECK-NEXT:    # in Loop: Header=BB0_2 Depth=1
+; CHECK-NEXT:    testl %r9d, %r9d
+; CHECK-NEXT:    js .LBB0_5
+; CHECK-NEXT:  # %bb.4:
+; CHECK-NEXT:    movl %r9d, %edx
+; CHECK-NEXT:  .LBB0_6: # %if.end9
+; CHECK-NEXT:    testl %edx, %edx
+; CHECK-NEXT:    jne .LBB0_7
+; CHECK-NEXT:  .LBB0_8: # %if.end13
+; CHECK-NEXT:    xorl %r8d, %r8d
+; CHECK-NEXT:    jmp .LBB0_1
+; CHECK-NEXT:  .LBB0_7: # %while.body.lr.ph
+; CHECK-NEXT:    movl %ecx, %eax
+; CHECK-NEXT:    retq
+entry:
+  br i1 %tobool.not, label %if.end13, label %j.preheader
+
+  j.preheader:       ; preds = %if.end13, %entry
+  %h.0.ph = phi i32 [ 1, %entry ], [ 0, %if.end13 ]
+  br label %j
+
+  j:                 ; preds = %if.then4, %j.preheader
+  %1 = phi i32 [ %div2, %if.then4 ], [ 0, %j.preheader ]
+  %rem1 = srem i32 1, %0
+  %cmp = icmp slt i32 %1, 0
+  %or.cond = select i1 false, i1 true, i1 %cmp
+  br i1 %or.cond, label %if.then4, label %if.end9
+
+  if.then4:          ; preds = %j
+  %div2 = sdiv i32 1, 0
+  %rem5 = srem i32 1, %h.0.ph
+  br i1 %tobool.not, label %if.end9, label %j
+
+  if.end9:           ; preds = %if.then4, %j
+  %2 = phi i32 [ 0, %j ], [ %rem5, %if.then4 ]
+  %tobool10.not = icmp eq i32 %2, 0
+  br i1 %tobool10.not, label %if.end13, label %while.body.lr.ph
+
+  while.body.lr.ph:  ; preds = %if.end9
+  ret i32 %rem1
+
+  if.end13:          ; preds = %if.end9, %entry
+  br label %j.preheader
+}
diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SLPVectorizer/X86/debug-info-salvage.ll b/llvm/test/Transforms/SLPVectorizer/X86/debug-info-salvage.ll
--- a/llvm/test/Transforms/SLPVectorizer/X86/debug-info-salvage.ll
+++ b/llvm/test/Transforms/SLPVectorizer/X86/debug-info-salvage.ll
@@ -0,0 +1,70 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
+; RUN: opt -S --passes=slp-vectorizer -mtriple=x86_64-unknown-linux -mattr=+avx2 < %s | FileCheck %s
+
+define void @test() {
+; CHECK-LABEL: define void @test(
+; CHECK-SAME: ) #[[ATTR0:[0-9]+]] {
+; CHECK-NEXT:  [[ENTRY:.*:]]
+; CHECK-NEXT:    br label %[[COND_END_I:.*]]
+; CHECK:       [[COND_END_I]]:
+; CHECK-NEXT:      #dbg_value(!DIArgList(i32 0, i32 undef), [[META3:![0-9]+]], !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_or, DW_OP_stack_value), [[META5:![0-9]+]])
+; CHECK-NEXT:    [[TMP0:%.*]] = call <2 x i32> @llvm.umin.v2i32(<2 x i32> zeroinitializer, <2 x i32> zeroinitializer)
+; CHECK-NEXT:    [[TMP1:%.*]] = select <2 x i1> zeroinitializer, <2 x i32> zeroinitializer, <2 x i32> [[TMP0]]
+; CHECK-NEXT:    [[TMP2:%.*]] = shl <2 x i32> [[TMP1]], <i32 0, i32 16>
+; CHECK-NEXT:    [[TMP3:%.*]] = or <2 x i32> [[TMP2]], zeroinitializer
+; CHECK-NEXT:    [[TMP4:%.*]] = or <2 x i32> [[TMP3]], zeroinitializer
+; CHECK-NEXT:    [[TMP5:%.*]] = or <2 x i32> [[TMP4]], zeroinitializer
+; CHECK-NEXT:    store <2 x i32> [[TMP5]], ptr null, align 4
+; CHECK-NEXT:    ret void
+;
+entry:
+  %arrayidx51.1.i = getelementptr i8, ptr null, i64 4
+  %retval.sroa.3.0.insert.ext.i.i = zext i8 0 to i32
+  %retval.sroa.2.0.insert.ext.i.i = zext i8 0 to i32
+  br label %cond.end.i
+
+cond.end.i:
+  %add46.i30 = or i32 0, %retval.sroa.2.0.insert.ext.i.i
+  %add49.i = or i32 0, %retval.sroa.3.0.insert.ext.i.i
+  #dbg_value(i32 %add49.i, !8, !DIExpression(), !16)
+  %0 = tail call i32 @llvm.umin.i32(i32 %add46.i30, i32 0)
+  %cmp.i14.i.i.i = icmp slt i32 %add49.i, 0
+  %block_color.sroa.7.0.insert.ext.i = select i1 %cmp.i14.i.i.i, i32 0, i32 0
+  %block_color.sroa.7.0.insert.shift.i = shl i32 %block_color.sroa.7.0.insert.ext.i, 16
+  %block_color.sroa.5.0.insert.ext.i = select i1 false, i32 0, i32 %0
+  %block_color.sroa.5.0.insert.shift.i = shl i32 %block_color.sroa.5.0.insert.ext.i, 0
+  %block_color.sroa.7.0.insert.insert.i = or i32 %block_color.sroa.7.0.insert.shift.i, %block_color.sroa.5.0.insert.shift.i
+  %block_color.sroa.5.0.insert.insert.i = or i32 %block_color.sroa.7.0.insert.insert.i, 0
+  %block_color.sroa.0.0.insert.insert.i = or i32 %block_color.sroa.5.0.insert.insert.i, 0
+  store i32 %block_color.sroa.0.0.insert.insert.i, ptr null, align 4
+  %add46.1.i = or i32 0, %retval.sroa.2.0.insert.ext.i.i
+  %add49.1.i = or i32 0, %retval.sroa.3.0.insert.ext.i.i
+  %cmp.i11.i.i.1.i = icmp slt i32 %add46.1.i, 0
+  %1 = tail call i32 @llvm.umin.i32(i32 %add49.1.i, i32 0)
+  %block_color.sroa.7.0.insert.ext.1.i = select i1 false, i32 0, i32 %1
+  %block_color.sroa.7.0.insert.shift.1.i = shl i32 %block_color.sroa.7.0.insert.ext.1.i, 16
+  %block_color.sroa.5.0.insert.ext.1.i = select i1 %cmp.i11.i.i.1.i, i32 0, i32 0
+  %block_color.sroa.5.0.insert.shift.1.i = shl i32 %block_color.sroa.5.0.insert.ext.1.i, 0
+  %block_color.sroa.7.0.insert.insert.1.i = or i32 %block_color.sroa.7.0.insert.shift.1.i, %block_color.sroa.5.0.insert.shift.1.i
+  %block_color.sroa.5.0.insert.insert.1.i = or i32 %block_color.sroa.7.0.insert.insert.1.i, 0
+  %block_color.sroa.0.0.insert.insert.1.i = or i32 %block_color.sroa.5.0.insert.insert.1.i, 0
+  store i32 %block_color.sroa.0.0.insert.insert.1.i, ptr %arrayidx51.1.i, align 4
+  ret void
+}
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!7}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_14, file: !1)
+!1 = !DIFile(filename: "q.cpp", directory: "/tmp")
+!7 = !{i32 2, !"Debug Info Version", i32 3}
+!8 = !DILocalVariable(name: "sb", arg: 4, scope: !9)
+!9 = distinct !DISubprogram(name: "color_rgba", unit: !0)
+!16 = !DILocation(scope: !9)
+;.
+; CHECK: [[META0:![0-9]+]] = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_14, file: [[META1:![0-9]+]], isOptimized: false, runtimeVersion: 0, emissionKind: NoDebug)
+; CHECK: [[META1]] = !DIFile(filename: "q.cpp", directory: {{.*}})
+; CHECK: [[META3]] = !DILocalVariable(name: "sb", arg: 4, scope: [[META4:![0-9]+]])
+; CHECK: [[META4]] = distinct !DISubprogram(name: "color_rgba", scope: null, spFlags: DISPFlagDefinition, unit: [[META0]])
+; CHECK: [[META5]] = !DILocation(line: 0, scope: [[META4]])
+;.
diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel
@@ -3410,6 +3410,7 @@
         ":__support_arg_list",
         ":__support_file_file",
         ":__support_macros_attributes",
+        ":types_FILE",
         ":printf_main",
         ":printf_writer",
     ],
